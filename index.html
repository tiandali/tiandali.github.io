<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="tiandali">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="tiandali">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tiandali">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>tiandali</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">tiandali</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/DOM精讲/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/DOM精讲/" itemprop="url">DOM精讲</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-04T19:37:34+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="DOM基础精讲"><a href="#DOM基础精讲" class="headerlink" title="DOM基础精讲"></a>DOM基础精讲</h4><blockquote>
<p>DOM：document object model 文档对象模型，提供一些属性和方法可以让我们去操作dom元素</p>
</blockquote>
<h4 id="1-获取DOM元素的方法"><a href="#1-获取DOM元素的方法" class="headerlink" title="1.获取DOM元素的方法"></a>1.获取DOM元素的方法</h4><ul>
<li>document.getElementById 一个元素对象</li>
<li>[context].getElementsByTagName 元素集合</li>
<li>[context].getElementsByClassName 元素集合</li>
<li>document.getElementsByName 节点集合</li>
<li>document.documentElement 获取整个HTML对象</li>
<li>document.body 获取整个body对象</li>
<li>document.head 获取整个head对象</li>
<li>[context].querySelector 一个元素对象</li>
<li>[context].querySelectorAll 获取元素集合</li>
<li>document.docuemnt.clientWidth||docuemnt.body.clientWidth窗口的宽</li>
<li>document.docuemnt.clientHight||docuemnt.body.clientHight窗口的高<h5 id="1-getElementById"><a href="#1-getElementById" class="headerlink" title="1.getElementById"></a>1.getElementById</h5><blockquote>
<p>此方法的上下文只能是document，一个HTML页面中元素的ID理论上是不能重复的</p>
<ul>
<li>如果页面中的ID重复了，我们获取的结果是第一个ID对应的元素对象</li>
<li>在IE7及更低版本浏览器中，会把表单元素的name值当做id来识别使用（项目中尽量不要让表单的name和其它元素的id相同）</li>
<li>如果我们把JS放在结构的下面，我们可以直接使用ID值来获取这个元素（不需要通过getElementById获取），而且这种方式会把页面中所有ID是他的元素都获取到（元素对象/元素集合）  （这种方式不推荐）</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;获取页面中ID值为#box1的所有元素标签</span></span><br><span class="line"><span class="keyword">var</span> allList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>),</span><br><span class="line">    result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; allList.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = allList[i];</span><br><span class="line">    item.id === <span class="string">'box1'</span> ? result.push(item) : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<h5 id="2-getElementsByTagName"><a href="#2-getElementsByTagName" class="headerlink" title="2.getElementsByTagName"></a>2.getElementsByTagName</h5><blockquote>
<ul>
<li>上下文是可以自己来指定</li>
<li>获取到的结果是一个元素集合（类数组集合）<br>获取的结果是集合，哪怕集合中只有一项，我们想要操作这一项（元素对象），需要先从集合中获取出来，然后再操作</li>
<li>在指定的上下文中，获取所有子子孙孙元素中标签名叫做这个的(后代筛选)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var bodyBox=document.getElementsByTagName(&apos;body&apos;);</span><br><span class="line">bodyBox.getElementsByTagName(&apos;div&apos;);//-&gt;Uncaught TypeError: bodyBox.getElementsByTagName is not a function 此时的bodyBox是一个类数组集合，我们需要使用的是其中的第一项，而不是整个集合</span><br><span class="line">bodyBox[0].getElementsByTagName(&apos;div&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h5 id="3-getElementsByClassName"><a href="#3-getElementsByClassName" class="headerlink" title="3.getElementsByClassName"></a>3.getElementsByClassName</h5><blockquote>
<ul>
<li>上下文也可以随意指定，获取的结果也是一个元素集合（类数组集合）</li>
<li>真实项目中我们经常会通过样式类名来获取元素，getElementsByClassName这个方法在IE6~8浏览器中是不兼容的<br>封装dom处理兼容问题</li>
</ul>
</blockquote>
<h5 id="4-getElementsByName"><a href="#4-getElementsByName" class="headerlink" title="4.getElementsByName"></a>4.getElementsByName</h5><blockquote>
<ul>
<li>通过元素的NAME属性值获取一组元素（类数组：节点集合 NodeList）</li>
<li>它的上下文也只能是document</li>
<li>IE浏览器只能识别表单元素的name属性值，所以我们这个方法一般都是用来操作表单元素的</li>
</ul>
</blockquote>
<h5 id="5-document-documentElement-document-body"><a href="#5-document-documentElement-document-body" class="headerlink" title="5.document.documentElement / document.body"></a>5.document.documentElement / document.body</h5><blockquote>
<p>获取html或者body（一个元素对象）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.clientWidth||<span class="built_in">document</span>.body.clientWidth <span class="comment">//=&gt;获取当前浏览器窗口可视区域的宽度（当前页面一屏幕的宽度）</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.clientHeight||<span class="built_in">document</span>.body.clientHeight<span class="comment">//=&gt;获取当前浏览器窗口可视区域的高度（当前页面一屏幕的高度）</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="6-querySelector-querySelectorAll"><a href="#6-querySelector-querySelectorAll" class="headerlink" title="6.querySelector / querySelectorAll"></a>6.querySelector / querySelectorAll</h5><blockquote>
<p>在IE6~8下不兼容，而且也没什么特别好办法处理它的兼容，所以这两个方法一般多用于移动端开发使用<br><code>querySelector</code>：获取一个元素对象<br>console.log(documengt.querySelect(“#list li:nth-child(2)”));获取id是list下面的第二个li。<br><code>querySelectorAll</code>：获取的是一个元素集合<br>只要是CSS支持的选择器，这里大部分都支持</p>
</blockquote>
<h4 id="2-DOM节点的分类"><a href="#2-DOM节点的分类" class="headerlink" title="2.DOM节点的分类"></a>2.DOM节点的分类</h4><blockquote>
<p>node：节点，浏览器认为在一个HTML页面中的所有内容都是节点（包括标签、注释、文字文本等）</p>
<ul>
<li>元素节点：HTML标签</li>
<li>文本节点：文字内容（高版本浏览器会把空格和换行也当做文本节点）</li>
<li>注释节点：注释内容</li>
<li>document文档节点</li>
<li>…</li>
</ul>
</blockquote>
<h5 id="1-元素节点"><a href="#1-元素节点" class="headerlink" title="1.元素节点"></a>1.元素节点</h5><ul>
<li>nodeType：1</li>
<li>nodeName：大写标签名(在部分浏览器的怪异模式下,我们写的标签名是小写,它获取的就是小写…)</li>
<li>nodeValue：null</li>
<li>[curEle].tagName:获取当前元素的标签名（获取的标签名一般都是大写）<h5 id="2-文本节点"><a href="#2-文本节点" class="headerlink" title="2.文本节点"></a>2.文本节点</h5></li>
<li>nodeType：3</li>
<li>nodeName：#text</li>
<li>nodeValue：文本内容<h5 id="3-注释节点"><a href="#3-注释节点" class="headerlink" title="3.注释节点"></a>3.注释节点</h5></li>
<li>nodeType：8</li>
<li>nodeName：#comment</li>
<li>nodeValue：注释内容<h5 id="4-文档节点"><a href="#4-文档节点" class="headerlink" title="4.文档节点"></a>4.文档节点</h5></li>
<li>nodeType：9</li>
<li>nodeName：#document</li>
<li>nodeValue：null</li>
</ul>
<h4 id="3-DOM节点关系属性"><a href="#3-DOM节点关系属性" class="headerlink" title="3.DOM节点关系属性"></a>3.DOM节点关系属性</h4><blockquote>
<p>节点是用来描述页面中每一部分之间关系的，只要我可以获取页面中的一个节点，那么我就可以通过相关的属性和方法获取页面中所有的节点；</p>
</blockquote>
<h5 id="1-childNodes"><a href="#1-childNodes" class="headerlink" title="1.childNodes"></a>1.childNodes</h5><blockquote>
<p>获取当前元素所有的子节点（节点集合：类数组）<br>不仅仅是元素子节点，文本、注释等都会包含在内；子节点说明只是在儿子辈分中查找；</p>
</blockquote>
<h5 id="2-children"><a href="#2-children" class="headerlink" title="2.children"></a>2.children</h5><blockquote>
<p>获取所有的元素子节点（元素集合）<br>在IE6~8下获取的结果和标准浏览器中有区别（IE6~8中会把注释节点当做元素节点获取到）</p>
</blockquote>
<h5 id="3-parentNode"><a href="#3-parentNode" class="headerlink" title="3.parentNode"></a>3.parentNode</h5><blockquote>
<p>获取当前元素的父节点（元素对象）</p>
</blockquote>
<h5 id="4-previousSibling-amp-amp-nextSibling"><a href="#4-previousSibling-amp-amp-nextSibling" class="headerlink" title="4.previousSibling &amp;&amp; nextSibling"></a>4.previousSibling &amp;&amp; nextSibling</h5><blockquote>
<p>previousSibling：获取当前节点的上一个哥哥节点（不一定是元素节点也可能是文本或者注释）<br>nextSibling：获取当前节点的下一个弟弟节点</p>
</blockquote>
<h5 id="5-previousElementSibling-amp-amp-nextElementSibling"><a href="#5-previousElementSibling-amp-amp-nextElementSibling" class="headerlink" title="5.previousElementSibling &amp;&amp;  nextElementSibling"></a>5.previousElementSibling &amp;&amp;  nextElementSibling</h5><blockquote>
<p>previousElementSibling ：获取当前节点的上一个哥哥元素节点<br>nextElementSibling：获取当前节点的下一个弟弟元素节点<br>IE6~8下不兼容</p>
</blockquote>
<h5 id="6-firstChild-amp-amp-lastChild"><a href="#6-firstChild-amp-amp-lastChild" class="headerlink" title="6.firstChild &amp;&amp;  lastChild"></a>6.firstChild &amp;&amp;  lastChild</h5><blockquote>
<p>firstChild：当前元素所有子节点中的第一个（也不一定是元素节点，可能是文本和注释）<br>lastChild：当前元素所有子节点中的最后一个</p>
</blockquote>
<h5 id="7-firstElementChild-amp-amp-lastElementChild"><a href="#7-firstElementChild-amp-amp-lastElementChild" class="headerlink" title="7.firstElementChild   &amp;&amp;  lastElementChild"></a>7.firstElementChild   &amp;&amp;  lastElementChild</h5><blockquote>
<p>获取第一个元素子节点和最后一个元素子节点<br>IE6~8不兼容</p>
</blockquote>
<h4 id="4-创建和增加-以及-修改删除克隆DOM元素"><a href="#4-创建和增加-以及-修改删除克隆DOM元素" class="headerlink" title="4.创建和增加 以及 修改删除克隆DOM元素"></a>4.创建和增加 以及 修改删除克隆DOM元素</h4><blockquote>
<p>真实项目中，我们偶尔会在JS中动态创建一些HTML标签，然后把其增加到页面中</p>
</blockquote>
<h5 id="1-document-createElement"><a href="#1-document-createElement" class="headerlink" title="1.document.createElement"></a>1.document.createElement</h5><blockquote>
<p>在JS中动态创建一个HTML标签</p>
</blockquote>
<h5 id="2-appendChild"><a href="#2-appendChild" class="headerlink" title="2.appendChild"></a>2.appendChild</h5><blockquote>
<p>容器.appendChild(新元素)<br>把当前创建的新元素添加到容器的末尾位置</p>
</blockquote>
<h5 id="3-insertBefore"><a href="#3-insertBefore" class="headerlink" title="3.insertBefore"></a>3.insertBefore</h5><blockquote>
<p>容器.insertBefore(新元素，老元素)<br>在当前容器中，把新创建的元素增加到老元素之前</p>
</blockquote>
<h5 id="4-removeChild"><a href="#4-removeChild" class="headerlink" title="4.removeChild"></a>4.removeChild</h5><blockquote>
<p>容器.removeChild(元素)<br>在当前容器中把某一个元素移除掉</p>
</blockquote>
<h5 id="5-replaceChild"><a href="#5-replaceChild" class="headerlink" title="5.replaceChild"></a>5.replaceChild</h5><blockquote>
<p>容器.replaceChild(新元素,老元素)<br>在当前容器中，拿新元素替换老元素</p>
</blockquote>
<h5 id="6-cloneNode"><a href="#6-cloneNode" class="headerlink" title="6.cloneNode"></a>6.cloneNode</h5><blockquote>
<p>元素.cloneNode(false/true)<br>把原有的元素克隆一份一模一样的，false：只克隆当前元素本身，true：深度克隆，把当前元素本身以及元素的所有后代都进行克隆</p>
</blockquote>
<h5 id="7-set-get-remove-Attribute"><a href="#7-set-get-remove-Attribute" class="headerlink" title="7.set/get/remove]Attribute"></a>7.set/get/remove]Attribute</h5><blockquote>
<p>给当前元素设置/获取/移除 属性的（一般操作的都是它的自定义属性）<br>box.setAttribute(‘myIndex’,0)//(属性名，属性值)<br>box.getAttribute(‘myIndex’)//（属性名）<br>box.removeAttribute(‘myIndex’)</p>
<p>使用xxx.index=0 和 xxx.setAttribute(‘index’,0) 这两种设置自定义属性的区别？</p>
<ul>
<li>xxx.index：是把当前操作的元素当做一个普通对象，为其设置一个属性名（和页面中的HTML标签没关系）；</li>
<li>xxx.setAttribute：把元素当做特殊的元素对象来处理，设置的自定义属性是和页面结构中的DOM元素映射在一起的；</li>
</ul>
</blockquote>
<h5 id="8-document-creatDocumentFragment创建文档碎片"><a href="#8-document-creatDocumentFragment创建文档碎片" class="headerlink" title="8.document.creatDocumentFragment创建文档碎片"></a>8.document.creatDocumentFragment创建文档碎片</h5><p>JS中获取的元素对象，我们可以把它理解为两种角色：</p>
<ul>
<li>与页面HTML结构无关的普通对象</li>
<li>与页面HTML结构存在映射关系的元素对象</li>
</ul>
<blockquote>
<ul>
<li><p>元素对象中的内置属性，大部分都和页面的标签存在映射关系：<br>xxx.style.backgroundColor = ‘xxx’  此时不仅把JS中对象对应的属性值改变了，而且也会映射到页面的HTML标签上（标签中有一个style行内样式、元素的样式改变了）</p>
</li>
<li><p>xxx.className=’xxx’ 此时不仅是把JS对象中的属性值改了，而且页面中的标签增加了class样式类（可以看见的）<br>元素对象中的自定义属性：xxx.index=0 ；仅仅是把JS对象中增加了一个属性名（自定义的），和页面中的HTML没啥关系（在结构上看不见）</p>
</li>
<li>xxx.setAttribute：通过这种方式设置的自定义属性和之前提到的内置属性差不多，都是和HTML结构存在映射关系的（设置的自定义属性可以呈现在结构上）</li>
</ul>
</blockquote>
<h5 id="5-获取当前元素的上一个哥哥元素节点-兼容所有的浏览器"><a href="#5-获取当前元素的上一个哥哥元素节点-兼容所有的浏览器" class="headerlink" title="5. 获取当前元素的上一个哥哥元素节点(兼容所有的浏览器)"></a>5. 获取当前元素的上一个哥哥元素节点(兼容所有的浏览器)</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt; 首先获取当前元素的上一个哥哥节点，判断当前获取的节点是否为元素节点（nodeType===1），如果不是，基于当前获取的节点，找他的上一个哥哥节点...(找几次不知道)一直到找到的节点是元素节点为止</span></span><br><span class="line"><span class="comment">//=&gt; 如果在查找过程中，发现没有上一个哥哥节点了（找到头了），则不在继续查找</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prev</span>(<span class="params">curEle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = curEle.previousSibling;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p.nodeType !== <span class="number">1</span>) &#123;<span class="comment">//-&gt;p:p!==null</span></span><br><span class="line">        p = p.previousSibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;扩展：</span></span><br><span class="line"><span class="comment">//next：获取下一个弟弟元素节点</span></span><br><span class="line"><span class="comment">//prevAll：获取所有的哥哥元素节点</span></span><br><span class="line"><span class="comment">//nextAll：获取所有的弟弟元素节点</span></span><br><span class="line"><span class="comment">//siblings：获取所有的兄弟元素节点</span></span><br><span class="line"><span class="comment">//index：获取当前元素在兄弟中的排名索引</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>获取所有的子节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getChilds(ele)&#123;</span><br><span class="line">var childs=ele.childNodes;</span><br><span class="line">var ary =[];</span><br><span class="line">for(var i= 0;i&lt;childs.length;i++)&#123;</span><br><span class="line">var cur =childs[i];</span><br><span class="line">if(cur.nodetype==1)&#123;</span><br><span class="line">ary.push(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;　return ary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="DOM的重绘和回流"><a href="#DOM的重绘和回流" class="headerlink" title="DOM的重绘和回流"></a>DOM的重绘和回流</h3><blockquote>
<p>我们操作DOM或者修改DOM，基本上就是触发它的重绘和回流机制；</p>
<p>重绘：当一个元素的样式（特点：只有那些不修改元素位置的样式）发生改变的时候，浏览器会把当前元素重新进行渲染（DOM性能消耗低）；</p>
<p>回流：当一个元素的位置发生改变，浏览器会重新把整个页面的DOM结构进行计算，计算出所有元素的最新位置，然后再渲染（DOM性能消耗非常大）：</p>
<ul>
<li>1、新增或者删除一些元素；</li>
<li>2、把现有元素的位置改变；</li>
<li>3、窗口发生改变是可以监听resize事件<br>文档碎片:一个临时存储DOM元素的容器</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var frg=document.createDocumentFragment();</span><br><span class="line">for(var i=0;i&lt;ary.length;i++)&#123;//遍历数组每一项然后追加到文档碎片中</span><br><span class="line">frg.appendChild(ary[i]);</span><br><span class="line">&#125;</span><br><span class="line">listBox.appendChild(frg);//最后把文档碎片追加到容器当中，减少DOM回流，优化提高性能</span><br><span class="line">frg=null;//释放内存</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通俗理解：<br> 浏览器渲染一个页面的时候是按照”先创建一个dom树”-&gt;”加载css”-&gt;”生成渲染树render tree”-&gt;”把渲染树交给浏览器GPU进行绘制”，如果我们后期修改了元素的样式（但是没有改变大小和位置），浏览器会把当前元素重新生成渲染树，然后重新渲染，这个机制是重绘。但是一旦元素的位置或者大小等发生改变，浏览器就要从dom树重新计算渲染，这个机制就是回流（重排），不管是重排还是重绘都非常耗性能，在项目中，要特意重视这个问题，尽量减少操作dom引发的回流问题和重绘问题，基本上常用的解决方案：<br> 1.需要动态向页面追加元素的时候基于文档碎片或者先把需要增加的所有元素拼接成字符串最后统一进行添加。<br> 2.读写分离：把统一修改样式都放到一起执行，新版浏览器都有一个自己检测的机制，如果发现下面紧挨着的操作也是修改元素的样式，会把所有修改的事先存起来，知道遇到非修改样式的操作，会把之前存储的统一执行，引发一次回流和重绘<br>当然还有一些其他的方法，这些是最常注意的，减少dom的回流重绘是非常重要的性能优化手段之一。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/面向对象的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/面向对象的理解/" itemprop="url">面向对象的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-04T17:59:37+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="面向对象（OOP）"><a href="#面向对象（OOP）" class="headerlink" title="面向对象（OOP）"></a>面向对象（OOP）</h3><blockquote>
<p>面试对象是编程思想JAVA、PHP、C#、C++、.net(dot net)、Ruby、Python JS…这些都是面向对象编程的，（面向过程编程思想：C语言是面向过程的）。</p>
</blockquote>
<blockquote>
<p>HTML和CSS是标记语言不是编程语言，没有所谓的面向对象编程<br>LESS/SASS属于CSS预编译语言，旨在把CSS变为编程语言（面向对象）</p>
</blockquote>
<blockquote>
<p>对象、类、实例</p>
</blockquote>
<blockquote>
<p><code>对象</code>：编程语言中的对象是一个泛指，万物接对象（我们所要研究学习以及使用的都是对象）<br><code>类</code>：对象的具体细分（按照属性或者特性细分为一些类别）<br><code>实例</code>：某一类中具体的事物(拿出类别中的具体一个实例进行研究，那么当前类别下的其他实例也具备这些特点和特征。)</p>
</blockquote>
<h3 id="单例模式-singleton-Pattern"><a href="#单例模式-singleton-Pattern" class="headerlink" title="单例模式(singleton Pattern)"></a>单例模式(singleton Pattern)</h3><blockquote>
<p>在真实项目中，为了实现<code>模块化开发</code>或者团队协作开发，我们经常应用单例模式（一般业务逻辑部分的代码都是依托单例模式设计规划的）<br>单例模式命名 的由来：每一个命名空间都是js中Object这个内置类的实例而实例之间是相互独立不干扰的所以我们称之为单例：单独的实例。<br><code>作用</code>：把描述同一件事物的属性和特征进行分组、归类(存储在同一个堆内存空间中)因此避免了全局变量之间的冲突和污染。<br><code>本质</code>：实际上就是一个对象<br>优点：封装性、防止代码冲突和污染<br>模块的调用：<br>不同模块：模块名.属性名来调用<br>同模块：this.属性名，外面用模块名.属性名运行。</p>
</blockquote>
<h3 id="高级单例模式"><a href="#高级单例模式" class="headerlink" title="高级单例模式"></a>高级单例模式</h3><blockquote>
<p>基于JS高阶编程技巧<code>惰性思想</code>来实现的单例模式，并且可以把一些常用的设计模式（例如：命令模式、发布订阅设计模式、promise设计模式等）融合进来，最后清晰的规划我们的业务逻辑代码，方便后期二次开发和维护，这种设计思想综合体就是高级单例模式，也是项目中最常应用的</p>
<ul>
<li>1.在给命名空间赋值的时候不是直接赋值给一个对象，而是先执行匿名函数，形成一个私有作用域(不销毁的栈内存)在AA中创建一个堆内存，把堆内存地址赋值给命名空间.</li>
<li>2.好处是：我们完全可以在AA当中创造很多内容(变量or函数)，哪些需要供外面使用，我们就暴露给返回的对象中(模块化实现的思想)<br>有私有部分，有暴露外面的，功能全，满足需求。<br><code>缺点</code>：只能单个操作效率低，代码冗余。</li>
</ul>
</blockquote>
<h3 id="工厂模式-factory-pattern"><a href="#工厂模式-factory-pattern" class="headerlink" title="工厂模式(factory pattern)"></a>工厂模式(factory pattern)</h3><p>把实现相同功能的代码进行封装，从此来实现批量生产后期想要实现这个功能我们只需要执行函数即可<br>低耦合高内聚，减少代码冗余量。</p>
<blockquote>
<p>1）提供原材料—-新建一个对象<br>2）原材料加工生产—-对对象添加属性和方法<br>3）输出产品—-返回对象<br>缺点：加工出来的全是对象，没法识别，产品的差异化问题没法解决<br>本质：函数</p>
</blockquote>
<h3 id="构造函数-constructor"><a href="#构造函数-constructor" class="headerlink" title="构造函数(constructor)"></a>构造函数(constructor)</h3><blockquote>
<p>在普通函数执行的基础上’new xxx()’这样就不是普通函数执行了而是构造函数执行，当前的函数名称之为“类名”，接收的返回结果是当前类的一个实例</p>
<ul>
<li>这种构造函数设计模式执行，主要用于组件库类插件框架等的封装，平时编写业务逻辑一般不这样处理<br><code>注意事项</code>：<br>1.函数名首字符大写<br>2.this.xxx方式添加属性名，this 指实例<br>3.new 函数名运行，若不需要传参，小括号可不写，需要传参函数名后加括号。<br>4.new运行的函数称为构造函数<br>5.以实例为上下文运行构造函数，运行完成会自动返回这个实例<br>6、this.xxx这个属性是实例的属性，var a=10;只是函数内部的私有属性和实例无关<br>7.若手动增加的返回值return：<br>若返回的是引用类型的数据类型则会覆盖默认返回的实例<br>若返回的是基本类型的数据则不会覆盖。<br>8.this.xxx这些属性都是实例私有的，各个实例之间互不影响。</li>
</ul>
</blockquote>
<p><code>构造函数的创建方式</code></p>
<blockquote>
<p>new  Array(10):创建一个长度为10的数组，数组中的而每一项都是空；<br>new Array(“10”):如果只传递一个实参，并且实参不是数字，相当于把当前数值作为数组的第一项存储进来，如果传递多个实参，不是设置长度，而是把传递的内容当做数组的每一项存储起来。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;name:&apos;dali&apos;&#125;;//</span><br><span class="line">var obj=new Object();//=&gt;一般只用于创建空对象，如果需要增加键值对，创建完成后依次添加即可。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num=12;//字面量创建出来的是一个基本数据类型值（也是Number的一个实例，可以调取Number赋予他的方法</span><br><span class="line">var num=new Number(12);//构造函数方式创建出来的也是Number的一个实例（也是可以使用Number赋予的方法），但是获取的结果是对象数据类型的</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优点：实现产品的差异化，实现分类<br>缺点：所有的属性都是私有的，没法实现公有化<br>例如：有些功能是属于这个类的实例所公有的功能，不需要在每个实例上都实现一遍，只需要每个实例调用下公有的这个功能即可<br>普通函数执行 VS 构造函数执行</p>
</blockquote>
<blockquote>
<p><code>普通函数执行</code><br>1、开辟一个新的私有作用域<br>2、形参赋值<br>3、变量提升<br>4、代码自上而下执行（return后面的值就是当前函数返回的结果）<br>5、栈内存释放或者不释放问题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.function fn(num)&#123;</span><br><span class="line">2.    this.num=num;//=&gt;this:window 给全局对象增加一个num的属性名，属性值是10</span><br><span class="line">3.    var total=null;</span><br><span class="line">4.    total+=num;</span><br><span class="line">5.    return total;</span><br><span class="line">6.&#125;</span><br><span class="line">7.var f=fn(10);//=&gt;f:10</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>构造函数执行</code><br> 1、首先和普通函数执行一样，也需要开辟一个新的私有作用域<br>2、在私有作用域中完成类似于普通函数的操作：形参赋值以及变量提升 –都是<code>私有变量</code>。<br>3、在代码自上而下执行之前，构造函数有属于自己比较特殊的操作：<code>浏览器会在当前的作用域中默认创建一个对象数据类型的值（一个堆内存：暂不存储任何东西），并且会让当前函数中的执行主体this指向创建的这个对象（这个堆内存的地址）</code><br>4、像普通函数一样，代码自上而下执行：<code>this.xxx=xxx这里操作都是在给创建的这个对象（这个堆内存里）增加属性名和属性值</code><br>5、代码执行完成后，即时函数中没有写return，在构造函数模式中：<code>浏览器会默认的把创建的对象返回到函数的外面</code></p>
</blockquote>
<blockquote>
<p>构造函数执行，即具备普通函数执行的一面，也同时具备自己独有的一些操作；<br>在构造函数执行期间，<code>浏览器默认创建的对象（也就是函数体中的this）就是当前这个类的一个实例，代码执行中的this.xxx=xxx都是给实例设置&quot;私有属性&quot;，浏览器会把默认创建的实例返回，供外面接收，再次执行new Fn()，就是把上面的操作克隆一份，会形成新的实例（新的内存空间），所以说实例是相互独立的。返回的结果是Fn这个类的一个实例</code><br><code>深入理解构造函数执行的步骤</code><br>当构造函数或者类，执行的时候不需要传递任何的实参值，此时我们是否加小括号就不重要了（不传递实参的情况下，小括号可以省略）</p>
</blockquote>
<blockquote>
<p>构造函数执行，同时具备了普通函数执行的一面，也有自己特殊的一面，但是和实例相关的，只有自己特殊的一面才相关（也就是 this.xxx=xxx才相当于给当前实例增加的私有属性），函数体中出现的私有变量，和实例都没有直接的关系</p>
</blockquote>
<blockquote>
<p>通过类创建出来的每一个实例都是单独的个体（单独的堆内存空间），实例和实例之间是不相同并且独立互不影响的（市面上部分开发把这种模式叫做单例模式，这种说法是错的，JS中的这种模式叫做构造函数设计模式）</p>
</blockquote>
<blockquote>
<p>在构造函数体中，通过this.xxx=xxx给实例设置的属性都是当前实例的私有属性<br>当构造函数体中我们自己<code>手动的设置了return</code>（<code>默认返回的是实例:对象类型值</code>）, return的是一个<code>基本类型值</code>，对最后返回的实例<code>没有任何的影响</code>，但是如果返回的是<code>引用数据类型</code>的值，<code>会</code>把默认返回的实例<code>替换掉</code>；<br>构造函数执行的时候尽量减少return的使用，防止覆盖实例。<br>如果有return且后面没有返回值，就是结束代码执行的作用并不会覆盖返回的实例。</p>
</blockquote>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><blockquote>
<p>1、所有的函数都天生自带一个属性：prototype（原型）, 它是一个<code>对象</code>数据类型的值，在当前prototype对象中，存储了类需要给其实例使用的<code>公有</code>的属性和方法</p>
</blockquote>
<blockquote>
<p>2、prototype这个对象，浏览器会默认为其开一个<code>堆内存</code>，在这个堆内存中天生自带一个属性：<code>constructor</code>（构造函数），这个属性存储的值就是当前函数本身</p>
</blockquote>
<blockquote>
<p>3、每一个类的实例（每一个对象）都天生自带一个属性：<code>__proto__</code>属性值是当前对象所属类的原型（prototype）<br>原型的基础知识：<br>1.所有的函数（类）（构造函数）里有一个属性叫prototype，protoype是一个对象数据类型会开辟一个堆内存，存储了供其实例使用的公共属性和方法。<br>2.prototype这个对象自带一个属性constructor，他指向与构造函数本身。<br>3.每一个实例（对象）都自带一个属性<code>__proto__</code>这个属性指向所属类的原型</p>
</blockquote>
<blockquote>
<p>prototype里面的属性的都是公有的，所有实例都能访问到<br>构造函数里的this.xxx属性都是实例私有的</p>
</blockquote>
<blockquote>
<p>在实际项目基于面向对象开发的时候（构造原型设计模式）我们根据需要很多时候会定向类的原型（让类的原型指向自己开辟的堆内存）<br>存在的问题<br>1.自己开辟的堆内存中没有constructor属性，导致累的额原型构造函数缺失（解决：自己手动在堆内存中增加constructor属性）<br>2.当原型重定向后浏览器默认开辟的那个原型堆内存会被释放掉，如果之前存储了一些方法或者属性这些东西会丢失(所以内置类的原型不允许重定向到自己开辟的堆内存，因为内置类原型上自带的很多属性方法，重定向之后就都没了，这样是不被允许的)</p>
</blockquote>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><blockquote>
<p>属性查找顺序：<br>1.先在实例上找，若没找到则通过<code>__proto__</code>所属类的原型找，若还没找到，则继续通过<code>__proto__</code>去父类的原型上找…Object.prototype若没找到，则说明不存在。</p>
</blockquote>
<blockquote>
<p><code>isPrototypeOf</code> 判断一个对象是否是在另一个对象的原型链上<br><code>hasOwnproperty</code>判断是否是私有属性<br><code>propertyIsEnumerable</code>是否是可枚举的<br>toSring()转化为字符串，功能是用来检测数据类型，一定要调用的是原型上的toString方法<br>深入学习函数（函数的三种身份：普通函数、类、对象）</p>
<ul>
<li>普通函数<br>作用域，形参赋之，变量提升，代码从上到下<br>函数内变量查找的属性<br>内存释放</li>
<li>构造函数（类）</li>
<li>fn instanceOf Object//-&gt;true<br>Function.__proto__.__proto__==Object.prototype//-&gt;true</li>
</ul>
</blockquote>
<blockquote>
<p>Object.__proto__==Function.prototype//-&gt;true<br>对象</p>
</blockquote>
<blockquote>
<p><code>Object这个</code>类<code>是Function的一个实例
Function的原型是Function.prototype是Object这个类的一个实例
因为Function既是一个函数（类）也是一个对象，自带的\__proto__指向Function.prototype，而Function.prototype的\__proto__又指向Object的原型Object.prototype。因此可以说Function是Object的一个实例</code><br>所有对象都是Object的一实例。就是Object原型上的方法都可以用。<br>所有函数都是Function上的一个实例Function原型上的方法都可以用。call、aplly、bind都可以用<br>面试题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName();<span class="comment">//=&gt;2 把FOO作为对象,找其私有属性</span></span><br><span class="line">getName();<span class="comment">//=&gt;4 执行全局下的GET-NAME</span></span><br><span class="line">Foo().getName();<span class="comment">//=&gt;1 先把FOO作为普通函数执行,把执行的结果window调取GET-NAME在执行</span></span><br><span class="line"><span class="built_in">window</span>.getName();<span class="comment">//=&gt;1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName();<span class="comment">//=&gt;先获取Foo.getName的值(假设B),然后再new B()相当于创建B的实例 =&gt;2  (new Foo.getName;一样的)</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName();<span class="comment">//=&gt;new Foo()当做一个整体获取实例，把得到的实例在调取GET-NAME  =&gt;3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();</span><br><span class="line"><span class="comment">//=&gt;var f=new Foo()//=&gt;实例是this这是空的</span></span><br><span class="line"><span class="comment">//=&gt;new f.getName();  =&gt;new (f.getName)(); =&gt;3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obj.getX();//=&gt;先获取obj的getX的属性值，然后把获取的值执行</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call  apply bind"></a>call  apply bind</h3><blockquote>
<p>都是天生自带的方法(Function.prototype)，所有的函数都可以调取这三个方法<br><code>三个方法都是改变THIS指向的</code><br><code>call</code><br>fn.call(context,para1,…)<br>把fn方法执行，并且让fn方法中的this变为context,而para1…都是给fn传递的实参<br>1.非严格模式下如果参数不传或者第一个传递的是null、undefined，this指向window<br>2.严格模式下第一个参数是谁，this就指向谁（包括null、undefined）不传this是undefined</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;非严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">fn</span>:fn&#125;;</span><br><span class="line">fn();<span class="comment">//=&gt;this:window</span></span><br><span class="line">obj.fn();<span class="comment">//=&gt;this:obj</span></span><br><span class="line"><span class="keyword">var</span> opp=&#123;&#125;;</span><br><span class="line"><span class="comment">//opp.fn();//=&gt;报错:opp中没有fn这个属性</span></span><br><span class="line">fn.call(opp);<span class="comment">//=&gt;this:opp num1&amp;&amp;num2都是undefined</span></span><br><span class="line">fn.call(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//=&gt;this:1 num1=2 num2=undefined</span></span><br><span class="line">fn.call(opp,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//=&gt;this:opp num1=1 num2=2</span></span><br><span class="line"><span class="comment">//-&gt;CALL方法的几个特殊性</span></span><br><span class="line">fn.call();<span class="comment">//=&gt;this:window   num1&amp;&amp;num2都是undefined</span></span><br><span class="line">fn.call(<span class="literal">null</span>);<span class="comment">//=&gt;this:window</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>);<span class="comment">//=&gt;this:window</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;JS严格模式下</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">fn.call();<span class="comment">//=&gt;this:undefined</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>);<span class="comment">//=&gt;this:undefined</span></span><br><span class="line">fn.call(<span class="literal">null</span>);<span class="comment">//=&gt;this:null</span></span><br></pre></td></tr></table></figure>
<p><code>apply</code></p>
<blockquote>
<p>apply的语法和call基本一致，作用原理也基本一致，唯一的区别：apply把传递给函数的实参以数组形式存放（但是也相当于在给函数一个个的传递实参值）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(<span class="literal">null</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">fn.apply(<span class="literal">null</span>,[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]); <span class="comment">//=&gt;传递给fn的时候也是一个个的传递进去的</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><code>bind</code></p>
<blockquote>
<p>也是改变THIS的方法，它在IE6~8下不兼容；它和call(以及apply)改变this的原理不一样，区别于立即执行还是等待执行。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fn.call(opp,<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//=&gt;把fn执行,让fn中的this变为opp,并且把10&amp;&amp;20分别传递给fn</span></span><br><span class="line"></span><br><span class="line">fn.bind(opp,<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//=&gt;预先让fn中的this指向opp,并且把10和20预先传递给fn,此时的fn没有被执行(只有当执行的时候this和实参才会起到应有的作用)</span></span><br><span class="line"><span class="comment">//=&gt;需求：点击box这个盒子的时候，需要执行fn，并且让fn中的this指向opp</span></span><br><span class="line">oBox.onclick=fn; <span class="comment">//=&gt;点击的时候执行了fn,但此时fn中的this是oBox</span></span><br><span class="line"></span><br><span class="line">oBox.onclick=fn.call(opp); <span class="comment">//=&gt;绑定事件的时候就已经把fn立即执行了(call本身就是立即执行函数),然后把fn执行的返回值绑定给事件</span></span><br><span class="line"></span><br><span class="line">oBox.onclick=fn.bind(opp);</span><br><span class="line"><span class="comment">//=&gt;fn.bind(opp)：fn调取Function.prototype上的bind方法，执行这个方法返回了一个匿名函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function()&#123;</span></span><br><span class="line"><span class="comment"> *     fn.call(opp);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">oBox.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//=&gt;this:oBox</span></span><br><span class="line">	fn.call(opp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn1()&#123;console.log(1);&#125;</span><br><span class="line"> function fn2()&#123;console.log(2);&#125;</span><br><span class="line"> fn1.call(fn2);//=&gt;找到CALL-AA把它执行,CALL-AA中的THIS是FN1,第一个参数传递的是FN2  =&gt;在CALL-AA中执行的是FN1 =&gt;1</span><br><span class="line"></span><br><span class="line"> fn1.call.call(fn2);//=&gt;找到CALL-AA让它执行,CALL-AA中的THIS是FN1.CALL,第一个参数是FN2  (把FN1.CALL中的THIS变为FN2，再让FN1.CALL执行  =&gt;先找到CALL-AA，把它执行，只不过此时它中的THIS是FN2 =&gt;让FN2中的THIS变为UNDEFINED，因为执行FN1.CALL的时候没有传递参数值，然后让FN2执行)  =&gt;2</span><br><span class="line"></span><br><span class="line"> Function.prototype.call(fn1);//=&gt;先找到CALL-AA把它执行，它中的THIS是Function.prototype =&gt;让F.P中的THIS变为FN1,然后让F.P执行,F.P是一个匿名函数也是一个空函数，执行没有任何的输出</span><br><span class="line">Function.prototype.call.call(fn1);//=&gt;先找到CALL-AA把它执行，它中的THIS是F.P.CALL =&gt;把F.P.CALL中的THIS修改为FN1,让F.P.CALL执行  =&gt;F.P.CALL(CALL-AA)第二次把它执行(此时它里面的THIS已经是FN1) =&gt;这一次其实在CALL-AA中是让FN1执行 =&gt;1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>查看函数原型上的方法：<br>call/apply/bind-&gt;改变调用主体的this关键字<br>call()第一个参数：用来改变<code>.</code>前面方法的this关键字，从第二个参数开始，以散列式的方式给<code>.</code>前面的方法传参.—散列式.<br>fn.apply()第一个参数：用来改变<code>.</code>前面方法的this关键字，第二个参数是用来给<code>.</code>前面的方法传参（把所有的参数放在数组里传给<code>.</code>前面的方法）—打包式.</p>
</blockquote>
<p>非严格模式下</p>
<blockquote>
<p>call/apply第一个参数不传，传null,传undefined-&gt;<code>.</code>前面方法里的this都是window<br>严格模式下-》规范<br>好处：<br>1.更加安全高效<br>2.提高编译器编译代码的速度<br>3.跟高版本浏览器接轨<br>第一个参数不传是undefined，其他传什么就是什么<br>fn1.call.call.call.call(fn2);<br>最后一个call作用<br>1.让点前面方法里的this关键字改成fn2-&gt;call方法里this-&gt;fn2<br>2.让点前面方法运行-&gt;function.prototype.call()-&gt;this()-&gt;fn2()</p>
</blockquote>
<h3 id="hasOwnProperty-VS-in"><a href="#hasOwnProperty-VS-in" class="headerlink" title="hasOwnProperty VS in"></a>hasOwnProperty VS in</h3><blockquote>
<p>in：用来检测当前这个属性是否隶属于对象（不管是对象私有的还是公有的属性，只要有返回的就是true）</p>
</blockquote>
<blockquote>
<p>hasOwnProperty：用来检测当前这个属性是否是对象的私有属性（不仅要是对象的属性，而且需要是私有的才可以）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;name:&apos;珠峰培训&apos;,age:8&#125;;</span><br><span class="line">&apos;name&apos; in obj  //=&gt;true</span><br><span class="line">&apos;sex&apos; in obj   //=&gt;false</span><br><span class="line">&apos;hasOwnProperty&apos; in obj //=&gt;true  hasOwnProperty是Object这个内置类中提供的属性方法，只要当前对象是Object的一个实例，就可以使用这个方法</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(&apos;name&apos;) //=&gt;true</span><br><span class="line">obj.hasOwnProperty(&apos;hasOwnProperty&apos;) //=&gt;false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>检测一个属性是否是当前对象的公有属性<br>1、是对象的一个属性<br>2、不是对象的私有属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function hasPubProperty(attr,obj)&#123;</span><br><span class="line">    return (attr in obj) &amp;&amp; (obj.hasOwnProperty(attr)===false);</span><br><span class="line">&#125;</span><br><span class="line">hasPubProperty(&apos;hasOwnProperty&apos;,&#123;xxx:&apos;xxx&apos;&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="类的继承：封装和多态"><a href="#类的继承：封装和多态" class="headerlink" title="类的继承：封装和多态"></a>类的继承：封装和多态</h3><p><code>[封装]</code>：把实现一个功能的js代码进行封装主要目的：低耦合高内聚<br><code>[多态]</code>：重载：方法名相同，参数的个数或者类型不同，此时名字相同的方法叫做方法的重载（后台语言的重载），js中不存在重载的<br>重写：子类重写父类的方法<br><code>[继承]</code>：子类继承父类的方法和属性<br><code>原型继承</code>:让子类原型指向父类的一个实例。原型继承方式：B.prototype=new A();A的实例本身具备父类A的私有属性和公有方法，子类B的原型指向它，那么子类的B的实例就可以找到这些属性和方法了.<br>和传统后台语言的继承不一样，子类继承父类并不是把父类的属性方法克隆一份给子类的（这样处理子类和父类就没有直接关系了）js中的原型继承是让子类和父类建立原型链接方式，子类的实例调取父类原型上的方法都是基于原型链的查找机制完成的。存在问题是：子类可以重写父类原型上的方法（重写），子类和父类还有关系的<br>B.prototype.__proto__.getX=null;//把父类A的原型上的getX重写为null，A的其他实例会受到影响<br><code>原型继承存在的问题</code>：<br>1.父类实例私有的属性以及公有的属性都变为子类实例的共有属性<br>2.如果子类B的原型上之前有属性方法，重新执行A的实例后，之前的方法都没用了。</p>
<p><code>call继承</code>:把父类A作为普通函数执行，让A中的this变为B的实例，相当于给B的实例增加一些属性和方法<br>new A()把A作为类创建它的实例this:实例。<br>A()把A当做普通函数执行this：window<br><code>弊端</code>：把父类A当做普通函数执行，和父类原型没有关系了，仅仅是把A中的私有属性变为子类B实例的私有属性而已，A原型上的公有属性和B及它的实例没啥关系.<br><code>寄生组合继承</code>:A的私有变为B的私有，A的公有变为B的公有<br>和原型继承的唯一区别：B.prototype=new A();创建的A的实例虽然指向了A的原型但是实例中不是空的，存放了A的私有属性，这些属性变为B的公有属性，B.prototype=Object.create(A.prototype)：<code>好处</code>在于我们是创建一个没有任何私有属性的空对象，指向A的原型，这样B的公有属性中就不会存在A的私有属性。<br>ES6class类实现继承:创建类是有标准的语法的(这种语法创建出来的类只能new执行，不能当做普通函数执行)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Fn&#123;</span><br><span class="line">constructor(n,m)&#123;</span><br><span class="line">//等价于构造体，代表函数</span><br><span class="line">this.x=n;</span><br><span class="line">this.y=m;&#125;</span><br><span class="line">//直接给Fn的原型上设置方法(只能设置方法不能设置属性)：</span><br><span class="line">getX()&#123;&#125;</span><br><span class="line">//把Fn当做一个普通对象设置的私有方法(和实例没有关系)，同样只能设置方法不能写属性：</span><br><span class="line">static AA()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//属性可以添加在外面</span><br><span class="line">//Fn.prototype.bb=100;</span><br><span class="line">let f=new Fn(10,20)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">construtor()&#123;this.x=100;&#125;</span><br><span class="line">getX()&#123;console.log(this.x)&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;//extends类似于实现了原型继承。</span><br><span class="line">construtor()&#123;super();//类似于call继承，在这里super相当于把A的constructor给执行了并且让方法中的this是B的实例，super当中传递的实参都是在给A的constructor传递</span><br><span class="line">this.y=200;&#125;</span><br><span class="line">getY()&#123;console.log(this.y)&#125;</span><br><span class="line">&#125;</span><br><span class="line">let f= new B();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//public void fn(int n,int m)</span><br><span class="line">//public void fn(string n,string m)&#123;&#125;</span><br><span class="line">//public void fn(int n,int m,int z)&#123;&#125;</span><br><span class="line">根据传递参数的不同执行不同的方法</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn(n,m)&#123;&#125;;</span><br><span class="line">function fn(n,m,x)&#123;</span><br><span class="line">//后面的方法会把前面的方法覆盖掉，不管传递多少实参，执行的都是后面的这个方法（js中的重载值得是：同一个方法根据传参不一样，实现不同的功能）</span><br><span class="line">&#125;;</span><br><span class="line">fn(1,2);</span><br><span class="line">fn(1,2,3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">this.x=100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype=&#123;</span><br><span class="line">constructor=A;</span><br><span class="line">getX:function()&#123;</span><br><span class="line">console.log(this.x)&#125;&#125;;</span><br><span class="line">function B()&#123;</span><br><span class="line">this.y=200&#125;</span><br><span class="line">B.prototype=new A();</span><br><span class="line">let f=new B();</span><br><span class="line">//原型继承：方式：B.prototype=new A();A的实例本身具备父类A的私有属性和公有方法，子类B的原型指向它，那么子类的B的实例就可以找到这些属性和方法了</span><br><span class="line">//和传统后台语言的继承不一样，子类继承父类并不是把父类的属性方法克隆一份给子类的（这样处理子类和父类就没有直接关系了）js中的原型继承是让子类和父类建立原型链接方式，子类的实例调取父类原型上的方法都是基于原型链的查找机制完成的。存在问题是：子类可以重写父类原型上的方法（重写），子类和父类还有关系的</span><br><span class="line">B.prototype.__proto__.getX=null;//把父类A的原型上的getX重写为null，A的其他实例会受到影响</span><br><span class="line">`原型继承存在的问题`：</span><br><span class="line">1.父类实例私有的属性以及公有的属性都变为子类实例的共有属性</span><br><span class="line">2.如果子类B的原型上之前有属性方法，重新执行A的实例后，之前的方法都没用了。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">this.x=100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype=&#123;</span><br><span class="line">constructor=A;</span><br><span class="line">getX:function()&#123;</span><br><span class="line">console.log(this.x)&#125;&#125;;</span><br><span class="line">function B()&#123;</span><br><span class="line">A.call(this);//call继承，把A执行,让A中的this变为f；</span><br><span class="line">this.y=200&#125;</span><br><span class="line"></span><br><span class="line">let f=new B();</span><br><span class="line"></span><br><span class="line">弊端：把父类A当做普通函数执行，和父类原型没有关系了，仅仅是把A中的私有属性变为子类B实例的私有属性而已，A原型上的公有属性和B及它的实例没啥关系</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">this.x=100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype=&#123;</span><br><span class="line">constructor=A;</span><br><span class="line">getX:function()&#123;</span><br><span class="line">console.log(this.x)&#125;&#125;;</span><br><span class="line">function B()&#123;</span><br><span class="line">A.call(this);//call继承，把A执行,让A中的this变为f；</span><br><span class="line">this.y=200&#125;</span><br><span class="line">//B.prototype=A.prototype;//这是组合继承，一般都不这样处理，容易修改父类A原型上的东西，导致A的其他实例也受到影响。</span><br><span class="line">B.prototype=Object.create(A.prototype)</span><br><span class="line">let f=new B();</span><br><span class="line">//Object.create:内置Object类天生自带的方法</span><br><span class="line">1.创建一个空对象</span><br><span class="line">2。让新创建的空对象__proto__指向第一个传递进来的对象（把OBJ作为新创建空对象的原型）</span><br><span class="line">let obj=&#123;name:&apos;haha&apos;&#125;;</span><br><span class="line">Object.create(obj)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/数据类型的检测方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/数据类型的检测方式/" itemprop="url">数据类型的检测方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-04T17:58:32+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="JS中的数据类型检测"><a href="#JS中的数据类型检测" class="headerlink" title="JS中的数据类型检测"></a>JS中的数据类型检测</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><blockquote>
<p>用来检测数据类型的运算符<br>语法：typeof  [value]<br>返回结果：首先是一个字符串，字符串中包含了我们需要检测的数据类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">12</span> =&gt;<span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> =&gt;<span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">''</span> =&gt;<span class="string">'string'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">typeof</span> flag =&gt;<span class="string">'boolean'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> =&gt;<span class="string">'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> =&gt;<span class="string">'object'</span> 虽然是基本类型值，但是它属于空对象指针，检测的结果是对象（局限性）</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; =&gt;<span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  =&gt;<span class="string">'function'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> [] =&gt;<span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> /^$/ =&gt;<span class="string">'object'</span></span><br><span class="line"><span class="comment">//=&gt;使用typeof有自己的局限性：不能具体细分出当前的值是数组还是正则（也就是不能细分对象类型的值）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> (<span class="number">1</span>&gt;<span class="number">1</span>?<span class="number">0</span>:<span class="number">2</span>);  =&gt;<span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>&gt;<span class="number">1</span>?<span class="number">0</span>:<span class="number">2</span>;  =&gt;<span class="number">2</span>  <span class="comment">//=&gt;先计算typeof 1-&gt;'number'  =&gt;'number'&gt;1?0:2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">typeof</span> [] =&gt;<span class="string">'string'</span></span><br><span class="line"><span class="comment">//=&gt;typeof []  =&gt;'object'</span></span><br><span class="line"><span class="comment">//=&gt;typeof 'object'  =&gt;'string'</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="instanceof-amp-constructor"><a href="#instanceof-amp-constructor" class="headerlink" title="instanceof &amp; constructor"></a>instanceof &amp; constructor</h4><blockquote>
<p>instanceof ：检测某一个实例是否隶属于某个类<br>constructor：构造函数</p>
<p>使用instanceof检测某个值是否属于某一个数据类型的内置类，从而检测出它是否是这个类型的值；使用instanceof可以实现typeof实现不了的，对对象类型值详细的区分检测；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>  =&gt;<span class="literal">true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">RegExp</span> =&gt;<span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>使用instanceof检测也有自己的弊端:<br>1、基本类型值无法基于它检测<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">12</span>;</span><br><span class="line">num.toFixed(<span class="number">2</span>)  =&gt;<span class="string">'12.00'</span>  <span class="comment">//=&gt;12是Number类的一个实例，可以调取Number.prototype上的方法，但是它是基本类型值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2=<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">12</span>);</span><br><span class="line">num2.toFixed(<span class="number">2</span>) =&gt;<span class="string">'12.00'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> num =&gt;<span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> num2 =&gt;<span class="string">'object'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;不管是哪一种方式创建基本类型值，都是自己所属类的实例（只不过类型不一样而已）</span></span><br><span class="line">num <span class="keyword">instanceof</span> <span class="built_in">Number</span>  =&gt;<span class="literal">false</span></span><br><span class="line">num2 <span class="keyword">instanceof</span> <span class="built_in">Number</span> =&gt;<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>2、instanceof检测的原理是基于原型链检测的：只要当前类在实例的原型链上，最后返回的结果都是true<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[];</span><br><span class="line">ary <span class="keyword">instanceof</span> <span class="built_in">Array</span>  =&gt;<span class="literal">true</span></span><br><span class="line">ary <span class="keyword">instanceof</span> <span class="built_in">Object</span> =&gt;<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Fn.prototype=<span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//=&gt;原型继承(Fn是Array的子类)</span></span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> Fn();</span><br><span class="line">f <span class="keyword">instanceof</span> <span class="built_in">Array</span> =&gt;<span class="literal">true</span> <span class="comment">//=&gt;但是我们的f其实不应该是数组，虽然在它的原型上可以找到数组，但是它不具备数组的基础结构，这也是instanceof的弊端</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><code>constructor</code></p>
<blockquote>
<p>获取当前要检测数据值的constructor，判断它是否是某一个数据类型内置类来检测<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[];</span><br><span class="line">ary.constructor===<span class="function"><span class="params">Array</span> =&gt;</span><span class="literal">true</span></span><br><span class="line">ary.constructor===<span class="function"><span class="params">RegExp</span> =&gt;</span><span class="literal">false</span></span><br><span class="line">ary.constructor===<span class="function"><span class="params">Object</span> =&gt;</span><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">ary.constructor=<span class="string">'AA'</span>;</span><br><span class="line">ary.constructor===<span class="function"><span class="params">Array</span> =&gt;</span><span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;constructor检测数据类型非常不可靠，因为这个属性是经常容易被修改的</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="Object-prototype-toString-call-value"><a href="#Object-prototype-toString-call-value" class="headerlink" title="Object.prototype.toString.call([value])"></a>Object.prototype.toString.call([value])</h4><blockquote>
<p>获取Object.prototype上的toString方法，让方法中的this变为需要检测的数据类型值，并且让方法执行</p>
<p>在Number、String、Boolean、Array、Function、RegExp…这些类的原型上都有一个toString方法：这个方法就是把本身的值转换为字符串的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">12</span>).toString() =&gt;<span class="string">'12'</span></span><br><span class="line">(<span class="literal">true</span>).toString() =&gt;<span class="string">'true'</span></span><br><span class="line">[<span class="number">12</span>,<span class="number">23</span>].toString() =&gt;<span class="string">'12,23'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>在Object这个类的原型上也有一个方法toString，但是这个方法并不是把值转换为字符串，而是<code>返回当前值的所属类详细信息，固定结构：&#39;[object 所属的类]&#39;</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">'珠峰'</span>&#125;;</span><br><span class="line">obj.toString() <span class="comment">//=&gt;"[object Object]" 调取的正是Object.prototype.toString</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * obj.toString()</span></span><br><span class="line"><span class="comment"> *   首先执行Object.prototype.toString方法</span></span><br><span class="line"><span class="comment"> *   这个方法中的this就是我们操作的数据值obj</span></span><br><span class="line"><span class="comment"> *   =&gt;总结：Object.prototype.toString执行的时候会返回当前方法中this的所属类信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   也就是，我想知道谁的所属类信息，我们就把这个toString方法执行，并且让this变为我们检测的这个数据值，那么方法返回的结果就是当前检测这个值的所属类信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Object.prototype.toString.call([value])</span></span><br><span class="line"><span class="comment"> *   (&#123;&#125;).toString.call([value])</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">12</span>) =&gt;<span class="string">"[object Number]"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) =&gt;<span class="string">"[object Boolean]"</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="string">"[object Number]"</span></span><br><span class="line"><span class="string">"[object Boolean]"</span></span><br><span class="line"><span class="string">"[object String]"</span></span><br><span class="line"><span class="string">"[object Null]"</span></span><br><span class="line"><span class="string">"[object Undefined]"</span></span><br><span class="line"><span class="string">"[object Object]"</span></span><br><span class="line"><span class="string">"[object Array]"</span></span><br><span class="line"><span class="string">"[object RegExp]"</span></span><br><span class="line"><span class="string">"[object Function]"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用toString检测数据类型，不管你是啥值，我们都可以正常检测出需要的结果（这个方法检测是万能的）</p>
</blockquote>
<h3 id="检测数据类型方法的封装"><a href="#检测数据类型方法的封装" class="headerlink" title="检测数据类型方法的封装"></a>检测数据类型方法的封装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        isNumber: <span class="string">'Number'</span>,</span><br><span class="line">        isString: <span class="string">'String'</span>,</span><br><span class="line">        isBoolean: <span class="string">'Boolean'</span>,</span><br><span class="line">        isNull: <span class="string">'Null'</span>,</span><br><span class="line">        isUndefined: <span class="string">'Undefined'</span>,</span><br><span class="line">        isPlanObject: <span class="string">'Object'</span>,</span><br><span class="line">        isArray: <span class="string">'Array'</span>,</span><br><span class="line">        isRegExp: <span class="string">'RegExp'</span>,</span><br><span class="line">        isFunction: <span class="string">'Function'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> check = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            check[key] = (<span class="function"><span class="keyword">function</span> (<span class="params">classValue</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\[object '</span> + classValue + <span class="string">'\\]'</span>).test(<span class="built_in">Object</span>.prototype.toString.call(val));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.check = check;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/数据类型/" itemprop="url">数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-04T17:58:09+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>基本数据类型(值类型)<ul>
<li>Number 数字</li>
<li>String 字符串</li>
<li>Boolean 布尔</li>
<li>null</li>
<li>Undefined</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>object 对象数据类型<ul>
<li>{} 对象object</li>
<li>[] 数组array</li>
<li>/^$/ 正则RegExp</li>
<li>Math数学函数(是window下的一个对象，提供了操作数字的属性和方法。)</li>
<li>Date 的实例（通过new date创造的时间值才是对象）</li>
<li>DOM元素对象</li>
<li>元素或者节点集合</li>
<li>…</li>
</ul>
</li>
<li>function 函数数据类型</li>
</ul>
</li>
</ul>
<h3 id="数据类型的操作原理"><a href="#数据类型的操作原理" class="headerlink" title="数据类型的操作原理"></a>数据类型的操作原理</h3><p><code>基本数据类型</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> b=a;</span><br><span class="line">b=<span class="number">13</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//=&gt;12</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>直接在当前作用域中创建了基本数据类型的值（或者说基本类型值直接存储在当前作用域中），然后把这个值和变量关联起来（一个变量只能关联一个值，关联下一个值后和之前关联的值就没关系了），我们把关联这个操作叫做 <strong>变量赋值</strong>，基本数据类型是直接 <strong>按值操作</strong> 的</p>
</blockquote>
<p><code>引用数据类型</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;<span class="attr">name</span>:<span class="string">'dali'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> p=o;</span><br><span class="line">p.name=<span class="string">'woshidali'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.name);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>引用数据类型不是直接按值操作的（它的结构复杂，要存储很多值，无法直接的创建值），在JS中遇到引用数据类型（对象或者函数），按照如下操作进行：</p>
<p>1、首先开辟一个新的内存空间（浏览器为其分配一个16进制的地址）<br>2、把需要存储的内容存储到内存空间中</p>
<ul>
<li>对象是把键值对依次存储到空间中</li>
<li>函数是把函数体中的代码当做 ‘字符串’ 存储到内存中</li>
</ul>
<p>3、把空间的地址赋值给对应的变量，所以我们也说：引用数据类型是<strong>按照空间的引用地址操作</strong>的</p>
</blockquote>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><blockquote>
<ul>
<li>number有整数 、浮点数值和NaN之分；</li>
<li>NaN：not a number 不是一个数，但是属于number类型的；</li>
<li>isNaN：这个方法是用来检测当前的值是否不是一个有效数字的，如果检测的值不是有效数字返回true，是有效数字返回false；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));<span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">1</span>));<span class="comment">//=&gt;false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'1'</span>));<span class="comment">//=&gt;false 它是有效数字:当浏览器发现我们检测的值不是number类型的时候,首先会默认的把值转换为number类型,然后再验证是否是有效的数字  '1'-&gt;1  isNaN(1)-&gt;false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'12px'</span>));<span class="comment">//=&gt;true  '12px'转换为数字不是有效数字,是NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>));<span class="comment">//=&gt;首先把布尔类型转换为数字 true -&gt;1 false -&gt;0  最后的结果是isNaN(1)-&gt;false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">false</span>));<span class="comment">//=&gt;false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">null</span>));<span class="comment">//=&gt;null转换为数字0 =&gt;false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">undefined</span>));<span class="comment">//=&gt;undefined转换为数字的NaN =&gt;true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="1-Number"><a href="#1-Number" class="headerlink" title="1.Number()"></a>1.Number()</h4><blockquote>
<ul>
<li>把其它数据类型的值转换为number类型；</li>
<li>Number属于强制类型转换，结果要么是纯数字，否则就是NaN<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">//=&gt;1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="comment">//=&gt;0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">//=&gt;0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">//=&gt;NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;使用Number把字符串转换为数字的时候，空字符串是零，其它字符串中如果出现的字符代表纯数字可以转为正常的数字，如果出现了任何一个非有效数字的字符，最后的结果都是NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>) <span class="comment">//=&gt;0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'12'</span>) <span class="comment">//=&gt;12</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'12.5'</span>) <span class="comment">//=&gt;12.5</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'true'</span>) <span class="comment">//=&gt;NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'12px'</span>) <span class="comment">//=&gt;NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;使用Number把引用数据类型转为数字类型的时候，先把引用类型转换为字符串(toString)，然后再把字符串转为数字</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;<span class="attr">name</span>:<span class="string">'zxt'</span>&#125;) <span class="comment">//=&gt; (&#123;name:'zxt'&#125;).toString() =&gt;"[object Object]"</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;&#125;)  <span class="comment">//(&#123;&#125;).toString() =&gt;"[object Object]" =&gt; NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">12</span>,<span class="number">23</span>]) <span class="comment">//[12,23].toString() =&gt; "12,23" =&gt;NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">12</span>]) <span class="comment">//[12].toString() =&gt; "12" =&gt;12</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="string">'aa'</span>]) <span class="comment">// =&gt;NaN</span></span><br><span class="line"><span class="built_in">Number</span>([]) <span class="comment">// =&gt;0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="regexp">/^$/</span>) <span class="comment">//(/^$/).toString() =&gt; "/^$/" =&gt;NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">//=&gt;NaN</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="2-parseInt-转换为整数"><a href="#2-parseInt-转换为整数" class="headerlink" title="2.parseInt() 转换为整数"></a>2.parseInt() 转换为整数</h4><blockquote>
<ul>
<li>也是把其它数据类型转换为数字，整体情况和Number用法一样，</li>
<li>区别在于：在转换字符串的时候，Number是只要出现一个非有效数字字符结果就是NaN；</li>
<li>parseInt没有这么霸道，它能把有效的部分识别出来转为数字，非有效的部分直接忽略掉；</li>
<li>查找机制：在查找转换的时候，按照从左到右的顺序依次查找，一直到遇到一个非有效数字字符结束（不管后面是否还有有效数字字符，都不再继续查找），把找到的转换为数字<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'12px'</span>)  <span class="comment">//=&gt;NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12px'</span>) <span class="comment">//=&gt;12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12px13'</span>) <span class="comment">//=&gt;12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'px13'</span>) <span class="comment">//=&gt;NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>([<span class="number">12</span>,<span class="number">13</span>]) <span class="comment">//=&gt;12</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="3-parseFloat"><a href="#3-parseFloat" class="headerlink" title="3.parseFloat()"></a>3.parseFloat()</h4><blockquote>
<ul>
<li>也是把其它数据类型转换为数字；</li>
<li>用法和parseInt一样，区别在于，parseFloat可以识别小数点；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12.5px'</span>) <span class="comment">//=&gt;12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'12.5px'</span>) <span class="comment">//=&gt;12.5</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'12.5.8px'</span>) <span class="comment">//=&gt;12.5</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'px12.5'</span>) <span class="comment">//=&gt;NaN</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="4-toFixed"><a href="#4-toFixed" class="headerlink" title="4.toFixed()"></a>4.toFixed()</h4><blockquote>
<p>控制数字保留小数点后面几位<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12.5</span>.toFixed() <span class="comment">//=&gt;不写参数,相当于不留小数点，会把数字四舍五入到整数上 =&gt;'13'</span></span><br><span class="line"><span class="number">12.4</span>.toFixed(<span class="number">0</span>) <span class="comment">//=&gt;'12'</span></span><br><span class="line"><span class="number">12.4</span>.toFixed(<span class="number">2</span>) <span class="comment">//=&gt;'12.40'</span></span><br><span class="line"><span class="built_in">Math</span>.PI.toFixed(<span class="number">2</span>) <span class="comment">//=&gt;'3.14'</span></span><br><span class="line"><span class="built_in">Math</span>.PI.toFixed(<span class="number">-2</span>) <span class="comment">//=&gt;Uncaught RangeError: toFixed() digits argument must be between 0 and 20</span></span><br><span class="line">###  String</span><br><span class="line">&gt; &gt; - 在JS中用单(双)引号包裹起来的都是字符串；</span><br><span class="line">&gt; - 字符串就是由零到多个字符组成的,以数字作为索引，从零开始的；</span><br><span class="line">&gt; - 有一个叫做length的属性，存储的是当前字符串中字符的个数（字符串的长度）；</span><br><span class="line">双包单，单包双。</span><br><span class="line">不能单包单，双包双，如果这样必须用转义符\</span><br><span class="line">转义字符：</span><br><span class="line">\\-&gt;\</span><br><span class="line">\<span class="string">'-&gt;'</span></span><br><span class="line">\<span class="string">"-&gt;"</span></span><br><span class="line">\r(回车)\n（换行）</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">12  //-&gt;number</span></span><br><span class="line"><span class="string">'12' //-&gt;string</span></span><br><span class="line"><span class="string">'[12,23]' //-&gt;string</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<ul>
<li>常用方法</li>
<li><p><code>str.charAt(索引)</code>：返回指定索引位置的字符，和str[索引]的区别在于，当指定的索引不存在的时候，中括号的方式获取的是undefined，而charAt获取的是空字符串；</p>
</li>
<li><p><code>str.charCodeAt(索引)</code>：在charAt基础上，把获取的字符变为unicode编码值（对应ASCII码表）；<br>48~57：0-9<br>65~90：A-Z<br>97~122：a-z<br>…</p>
</li>
<li><p><code>String.fromCharCode</code>(十进制的unicode值)：把值按照ASCII码表中的信息，转换为原有的字符，和charCodeAt正好对应；</p>
<ul>
<li>实现字符串截取的三个办法：<br><code>str.substr(n,m)</code>：从索引n开始，截取m个字符；<br><code>str.substring(n,m)</code>：从索引n开始，截取到索引为m处(不包含m)，把找到的部分截取；<br><code>str.slice(n,m)</code>：和substring语法一样，区别在于slice支持以负数做索引；</li>
</ul>
</li>
</ul>
<ul>
<li><p>当<code>索引是负数</code>的时候，浏览器在处理的时候，是用<code>字符串的总长度加上负数索引</code>，然后按照正数处理操作；</p>
</li>
<li><p>如果<code>只传递了n</code>（str.substr(n)/str.substring(n)），相当于从索引n开始一直<code>截取到字符串的末尾</code>；</p>
</li>
<li><p>如果传递的<code>索引超出</code>最大限制，也是把<code>能截取的部分截取掉</code>即可；</p>
</li>
<li><p>如果<code>一个参数都不传递</code>：相当于把整个字符串都截取（字符串的克隆）；<br>str.toUpperCase ：把字母全部大写<br>str.toLowerCase：把字母全局的小写</p>
<ul>
<li>str.indexOf：获取当前字符在字符串中第一次出现位置的索引；</li>
<li>str.lastIndexOf：获取的是最后一次出现位置的索引；</li>
<li>如果当前字符在字符串中没有出现过，结果是-1；我们根据这个规律可以验证一下当前字符串中是否包含某个字符；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str.indexOf(<span class="string">'?'</span>)===<span class="number">-1</span>)&#123;</span><br><span class="line">	<span class="comment">//=&gt;没有出现过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(str.indexOf(<span class="string">'?'</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">//=&gt;出现过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>str.split：按照某一个字符把字符串拆分成数组中的某一项，和数组中的join方法是对应的；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hobbyList = <span class="string">'music|movie|code'</span>;</span><br><span class="line">hobbyList.split(<span class="string">'|'</span>);</span><br><span class="line"><span class="comment">//=&gt; ['music','movie','code']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'name=zhufeng&amp;age=9'</span>;</span><br><span class="line">str.split(<span class="string">'='</span>);</span><br><span class="line"><span class="comment">//=&gt; ["name", "zhufeng&amp;age", "9"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'name=zhufeng&amp;age=9'</span>;</span><br><span class="line">str.split(<span class="regexp">/=|&amp;/g</span>);</span><br><span class="line"><span class="comment">//=&gt; ["name", "zhufeng", "age", "9"]</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<ul>
<li>str.replace：实现字符的替换；</li>
<li>执行一次replace只能替换一次，如果有好几个都需要替换，在不使用正则的情况下我们需要执行很多次replace；</li>
<li>有些需求即使执行很多次replace也实现不了，此时需要使用正则处理，真实项目中replace一般都是和正则搭配使用的<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'dali2017dali2018'</span>;</span><br><span class="line">str = str.replace(<span class="string">'dali'</span>,<span class="string">'tt'</span>)</span><br><span class="line"><span class="comment">//=&gt;'tt2017dali2018';</span></span><br><span class="line">str = str.replace(<span class="string">'dali'</span>,<span class="string">'tt'</span>)</span><br><span class="line"><span class="comment">//=&gt;'tt2017tt2018'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'dali2017tiandali2018'</span>;</span><br><span class="line">str.replace(<span class="regexp">/dali/g</span>,<span class="string">'tian'</span>)</span><br><span class="line"><span class="comment">//=&gt;'tian2017tiantian2018'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>match:一般用于正则捕获</p>
<blockquote>
<p><code>str.trimLeft</code>：去除字符串开始的空格<br><code>str.trimRight</code>：去除字符串结尾的空格<br><code>str.trim</code>：去除字符串首尾的空格<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">'  tian dali  '</span>;</span><br><span class="line">str.trimLeft(); <span class="comment">//=&gt; 'tian dali  '</span></span><br><span class="line">str.trimRight(); <span class="comment">//=&gt; '  tian dali'</span></span><br><span class="line">str.trim(); <span class="comment">//=&gt; 'tian dali'</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>…</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><blockquote>
<ul>
<li>只有两个值：true真/false假</li>
<li><code>Boolean()</code> 把其它数据类型转化为布尔类型，返回的结果为true或者false；</li>
<li>只有<code>0、NaN、空字符串、null、undefined</code>五个会转换为false，其余的都会转换为true<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>) <span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">//=&gt;false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">-1</span>) <span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>) <span class="comment">//=&gt;false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'xxx'</span>) <span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">//=&gt;false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">//=&gt;false</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">//=&gt;true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>取反，把其它数据类型先转换为布尔类型，然后再取反<br><code>!</code>：取一次反<br><code>!!</code>：取两次反(相当于没有取反，只剩把其它类型的值转换为布尔类型，和Boolean是相同的效果)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!<span class="literal">null</span> <span class="comment">//=&gt; true</span></span><br><span class="line">!!<span class="literal">undefined</span> <span class="comment">//=&gt;false</span></span><br><span class="line">![] <span class="comment">//=&gt;false</span></span><br><span class="line">!![] <span class="comment">//=&gt;true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><blockquote>
<ul>
<li>null：空对象指针，但它不是对象类型的，而是基本类型的，表示为空或者没有</li>
<li>undefined：未定义，也代表没有；变量只声明未定义返回的结果为undefined；</li>
</ul>
</blockquote>
<p><code>0或者空字符串</code> 和 <code>null或者undefined</code> 的区别</p>
<blockquote>
<p>0或者空字符串：挖了坑没种树<br>null或者undefined：连坑都没有挖</p>
<p>在JS中null属于没有开辟内存，而空字符串是开辟了内存，里面没有存内容而已，null消耗的性能更低</p>
</blockquote>
<p><code>null</code> 和 <code>undefined</code> 的区别</p>
<blockquote>
<p>null：意料之中的没有，一般都是当前暂时没有，后期基本上会有<br>undefined：意料之外的没有，一般都是当前没有，以后可能有可能没有，但是规划中是不计后面有没有的</p>
<p>dali（男）<br>他的女朋友是null<br>他的男朋友是undefined</p>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>数组也是对象数据类型的 <code>typeof [] -&gt;&#39;object&#39;</code></p>
<p>数组也有属性名，只不过属性名是数字，我们把数字属性名称之为它的索引：数组是以数字作为索引，索引从零开始，有一个length属性代表数组的长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[12,23,34]</span><br><span class="line">0:12</span><br><span class="line">1:23</span><br><span class="line">2:34</span><br><span class="line">length:3</span><br><span class="line">&gt;__proto__:Array(0)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>类数组：类似于数组，但是不是数组<br>1、通过getElementsByTagName获取的元素集合是类数组<br>2、函数中的实参集合arguments也是类数组<br>…</p>
</blockquote>
<h4 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h4><p>conslose.dir(Array.prototype)<br>push()内容添加到末尾<br>unshift()内容添加到开头<br>pop()删除末尾<br>shift()删除开头<br>sort()排序<br>reverse()倒序<br>splice(n,m)从n开始删除m个<br>前七个会改变原数组<br>slice(n,m)截取索引n开始到索引m，但不包括m.<br>concat()拼接<br>toString()转化为字符串<br>join()按照指定分隔符转为字符串<br>indexOf()是否包含某一项返回第一次出现索引<br>last indexOf()是否包含某一项返回最后一次出现索引<br>forEach()遍历每一项<br>map()遍历每一项在forEach基础上可以改值</p>
<p><code>console.dir(Array.prototype)</code></p>
<p>1、方法的意义和作用<br>2、方法的形参<br>3、方法的返回值<br>4、通过此方法，原来的数组是否发生了改变</p>
<h3 id="正则RegExp"><a href="#正则RegExp" class="headerlink" title="正则RegExp"></a>正则RegExp</h3><p>正则：用来处理字符串的一个规则。<br>处理：<br>1）<code>正则的匹配</code>：判断一个字符串是否符合我们制定的规则-&gt;test<br>例如：reg.test(str)<br>/\d/-&gt;包含一个0-9之间的数字<br>var reg=/\d/;<br>console.log(reg.test(“1”))-&gt;true<br>2）<code>正则的捕获</code>：把字符串符合我们正则规则的内容捕获到-&gt;exec<br>例如：reg.exec(str)<br>var reg=/\d/;<br>console.log(reg.exec(“1”))-&gt;[“1”,index:0,input:”1”]</p>
<h4 id="如何创建一个正则："><a href="#如何创建一个正则：" class="headerlink" title="如何创建一个正则："></a>如何创建一个正则：</h4><p>字面量方式：<br><code>var reg =/^\d+$/;</code><br>实例创建方式：<br><code>var reg =new RegExp(&quot;^\\d+$&quot;)</code><br>两种创建方式有区别：<br>1)在字面量方式中，我们//之间包起来的所有内容都是元字符，有的具有特殊的意义，大部分都是代表本身含义的普通的元字符，不能进行变量值的拼接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name =&quot;dali&quot;</span><br><span class="line">var reg =/^\d+&quot;+name+&quot;\d+$/g;</span><br><span class="line">console.log(reg.test(&quot;18dali24&quot;));-&gt;false</span><br><span class="line">console.log(reg.test(&quot;18&quot;&quot;&quot;&quot;&quot;nameeeee&quot;24&quot;));-&gt;true</span><br></pre></td></tr></table></figure></p>
<p>对于字符串拼接这样的需求只能使用实例创建的方式.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reg =new RegExp(&quot;^\\d+&quot;+name+&quot;\\d+$&quot;,&quot;g&quot;)</span><br><span class="line">console.log(reg.test(&quot;18dali24&quot;));-&gt;true</span><br></pre></td></tr></table></figure></p>
<p>2)字面量方式中的\d在实例创建当中要写出\d,前面加一个转义符，因为在字符串当中\d没有被识别成元字符<br>如何学习正则：<br>console.dir(RegExp.prototype)</p>
<h4 id="正则的组成：元字符"><a href="#正则的组成：元字符" class="headerlink" title="正则的组成：元字符"></a>正则的组成：元字符</h4><p>每一个正则表达式都是由元字符和修饰符组成的<br>元字符：在//之间具有意义的一些字符。<br><code>普通元字符</code>：只要在正则出现的元字符（基于字面量方式创建），除了特殊和有量词意义的以外，其余的都是普通元字符<br><code>修饰符</code><br>g(global)：全局匹配<br>i(ignoreCase)：忽略大小写匹配<br>m(multiline)：多行匹配</p>
<h4 id="1-具有特殊意义的元字符"><a href="#1-具有特殊意义的元字符" class="headerlink" title="1.具有特殊意义的元字符"></a>1.具有特殊意义的元字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\：转义字符。转义后面字符所代表的含义</span><br><span class="line">^:以某一个元字符开始</span><br><span class="line">$:以某一个元字符结束</span><br><span class="line">.:除了\n以外的任意字符</span><br><span class="line">():分组，把一个大正则本身划分为几个小正则。`可以改变x|y默认优先级`</span><br><span class="line">(?:):只匹配不捕获</span><br><span class="line">(?=):正向预查</span><br><span class="line">(?!):负向预查</span><br><span class="line">x|y：x或者y中的一个</span><br><span class="line">[xyz]:x或者y或者z中的一个</span><br><span class="line">[^xyz]除了x,y,z的任意一个字符。</span><br><span class="line">[a-z]:a-z之间的任何一个字符</span><br><span class="line">[^a-z]:除了a-z之间的任何一个字符</span><br><span class="line">\d :一个0-9之间的数字</span><br><span class="line">\D：除了0-9之间的数字以外的任何字符</span><br><span class="line">\b:匹配一个边界符</span><br><span class="line">\w:数字、字母、下划线中的任意一个字符[(0-9)(a-z)(A-Z)(_)]</span><br><span class="line">\s：匹配一个空白字符，空格，一个制表符、换页符...</span><br><span class="line">\n匹配一个换行符。</span><br></pre></td></tr></table></figure>
<p>reg=/^\d$/-&gt;<code>只能是`</code>一个<code>0-9之间的数字
console.log(reg.test(&quot;1&quot;))-&gt;true
console.log(reg.test(&quot;012&quot;))-&gt;false
var reg =/^0.2$/;指以0开头，以2结尾，中间可以是除了\n的任意字符。
var reg =/^0\.2$/;指以0开头，以2结尾，中间只能是</code>.`。就是只能是0.2</p>
<h4 id="2-代表出现次数的量词元字符"><a href="#2-代表出现次数的量词元字符" class="headerlink" title="2.代表出现次数的量词元字符"></a>2.代表出现次数的量词元字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*：出现零到多次</span><br><span class="line">+：出现一到多次</span><br><span class="line">?：出现零次或者一次。</span><br><span class="line">&#123;n&#125;：出现n次</span><br><span class="line">&#123;n,&#125;：出现n次到多次</span><br><span class="line">&#123;n,m&#125;：出现n到m次</span><br></pre></td></tr></table></figure>
<p>例如：<br>var reg =/^\d+$/指一到多个数字<br>验证手机号的正则：11位数字，第一位为1:<br>var reg =/^1\d{10}$/;<br><code>[]</code><br>1.中括号中出现的所有字符都是代表本身意思的字符（没有特殊的含义）<br>2.中括号当中不识别两位数<br><code>var reg =/^[12]$/;</code><br>代表的是1或者2中的一个。<br><code>var reg =/^[12-68]$/;</code><br>代表的是1、2-6、8三个当中的一个</p>
<h4 id="元字符详细解读"><a href="#元字符详细解读" class="headerlink" title="元字符详细解读"></a>元字符详细解读</h4><blockquote>
<p><code>()</code>：正则中的分组，也可以理解为一个大正则中的一个正则（包起来的部分是一个整体）；在正则中我们可以使用小括号<code>改变一些默认的优先级</code>；</p>
<p> 小分组还有第二个作用：<code>分组引用</code><br> 小分组的第三个作用：<code>分组捕获</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;分组引用：\1 或者 \2 ...出现和第N个分组一模一样的内容</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^([a-z])([a-z])\2([a-z])$/</span>; <span class="comment">//=&gt; 符合的字符串：foot、book、week、attr、http...</span></span><br></pre></td></tr></table></figure>
<p><code>[]</code></p>
<blockquote>
<p>[xyz] [^xyz] [a-z] [^a-z]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\w：数组字母下划线中的任意一个字符</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[a-zA-Z0-9_]$/</span>; <span class="comment">//=&gt;等价于\w</span></span><br><span class="line"></span><br><span class="line">中括号中出现的元字符，一般都代表本身的含义</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[.?+&amp;]+$/</span>; <span class="comment">//=&gt;里面的四个元字符都是本身含义，例如：点就是小数点了，不是所谓的任意字符...</span></span><br><span class="line"></span><br><span class="line">需求：描述样式类名的规则（数字、字母、下划线、-），并且不能以-开头</span><br><span class="line"><span class="comment">//var reg = /^[\w-]+$/;</span></span><br><span class="line"><span class="comment">//var reg = /^[0-9a-zA-Z_-]+$/; //=&gt;没有处理以-开头的情况</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\w[\w-]*$/</span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><code>|</code>或，操作较混乱<br>例如var reg =/^18|19$/;正常来说是18或者19.<br>但是实际中一下情况都是true<br>1）1开头9结尾<br>2）18或者19<br>3）含有18或者19，例如819也是true<br>可以用（）改变x|y的优先级。</p>
<h3 id="正则的分组"><a href="#正则的分组" class="headerlink" title="正则的分组"></a>正则的分组</h3><p>1.改变优先级<br>2.分组引用<br>3.分组捕获,可以捕获大小正则里的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\2代表和第二个分组出现一模一样的内容；\1代表和一个分组出现一模一样的内容；</span><br><span class="line">var reg =/^(\w)\1(\w)\2$/;</span><br><span class="line">console.log(reg.test(&quot;zzff&quot;));-&gt;true</span><br><span class="line">console.log(reg.test(&quot;z1f_&quot;));-&gt;false</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var reg =/^(\d&#123;2&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(?:\d&#123;2&#125;)(\d)(\d|x)$/;</span><br><span class="line">var str =&quot;654202199404233011&quot;;</span><br><span class="line">console.log(reg.exec(str));</span><br><span class="line">//ary=[&quot;654202199404233011&quot;,&quot;65&quot;,&quot;4202&quot;,&quot;1994&quot;,&quot;04&quot;,&quot;23&quot;,&quot;1&quot;,&quot;1&quot;,index:0,input:&quot;654202199404233011&quot;]</span><br><span class="line">//ary[0]大正则捕获的内容</span><br><span class="line">ary[1]第一个分组捕获的内容</span><br><span class="line">...</span><br><span class="line">（?:）：在分组中只匹配不捕获</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ####  正则的匹配</span><br><span class="line">`正则的匹配`：判断一个字符串是否符合我们制定的规则-&gt;test</span><br><span class="line">var reg=/\d/;</span><br><span class="line">console.log(reg.test(&quot;1&quot;))-&gt;true</span><br><span class="line"></span><br><span class="line"> ###  正则的捕获</span><br><span class="line">&gt; 把当前字符串中符合正则的字符捕获到</span><br><span class="line">&gt; RegExp.prototype：`exec` 实现正则捕获的方法</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var str = &apos;珠峰培训2017扬帆起航2018&apos;;</span><br><span class="line">var reg = /\d+/;</span><br><span class="line"></span><br><span class="line">reg.exec(str);</span><br><span class="line">/*</span><br><span class="line"> * 当正则捕获的时候：</span><br><span class="line"> * 1、先去验证当前字符串和正则是否匹配，如果不匹配返回的结果是null（没有捕获到任何的内容）</span><br><span class="line"> * 2、如果匹配，从字符串最左边开始，向右查找到匹配的内容，并且把匹配的内容返回</span><br><span class="line"> *</span><br><span class="line"> * exec捕获到结果的格式：</span><br><span class="line"> * -&gt; 获取的结果是一个数组</span><br><span class="line"> * -&gt; 数组中的第一项是当前本次大正则在字符串中匹配到的结果</span><br><span class="line"> * -&gt; index：记录了当前本次捕获到结果的起始索引</span><br><span class="line"> * -&gt; input：当前正则操作的原始字符串</span><br><span class="line"> * -&gt; 如果当前正则中有分组，获取的数组中，从第二项开始都是每个小分组，本次匹配到的结果（通过exec可以把分组中的内容捕获到）</span><br><span class="line"> *</span><br><span class="line"> * 执行一次exec只能把符合正则规则条件中的一个内容捕获都，如果还有其它符合规则的，需要在次执行exec才有可能捕获到</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h4 id="懒惰性"><a href="#懒惰性" class="headerlink" title="懒惰性"></a><code>懒惰性</code></h4><p>每一次执行exec只捕获第一个匹配的内容，在不进行任何处理的情况下，在执行多次捕获，捕获的还是第一个匹配的内容。<br>lastindex:是正则每一次捕获在字符串中开始查找的位置，默认的值是0.<br><code>如何解决懒惰性</code>：在正则的末尾加一个修饰符“g”<br><code>原理</code>：加了全局修饰符g，正则每一次捕获结束后，我们的lastindex的值都变为了最新的值，下一次捕获从最新的位置开始查找，这样的就可以把所有需要捕获的内容都捕获到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;a134b&quot;;</span><br><span class="line">var str2=&quot;cc123dd&quot;;</span><br><span class="line">var reg=/\w+/g;</span><br><span class="line">console.log(reg.exec(str));//a134b</span><br><span class="line">conslole.log(reg.lastIndex);//5</span><br><span class="line">console.log(reg.exec(str2));//dd</span><br><span class="line">conslole.log(reg.lastIndex);//7</span><br><span class="line">console.log(reg.exec(str2));//null</span><br><span class="line">conslole.log(reg.lastIndex);//0</span><br><span class="line">console.log(reg.exec(str));//a134b</span><br></pre></td></tr></table></figure>
<p>自己编写程序获取正则捕获的所有内容，一定不能忘记加g<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">没有分组一般就是三个参数：content内容，index索引，input原始字符串</span><br><span class="line">arguments[0]是大正则捕获的内容。</span><br><span class="line">arguments[1]一般就是对应的第1个分组的捕获的内容</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>封装一个方法把匹配的内容一次性捕获到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var reg =/\d+/g;</span><br><span class="line">var str =&quot;d20a21l22i23&quot;;</span><br><span class="line">var ary =[];</span><br><span class="line">var res = reg.exec(str);</span><br><span class="line">while(res)&#123;</span><br><span class="line">ary.push(res[0]);</span><br><span class="line">res = reg.exec(str);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ary)</span><br><span class="line"></span><br><span class="line">----------//或者如下</span><br><span class="line">  RegExp.prototype.allExec=function () &#123;</span><br><span class="line">  if(!this.global)&#123;return this.exec&#125;;</span><br><span class="line">        var ary=[];</span><br><span class="line">        var result;</span><br><span class="line">        while(result==this.exec(str))&#123;</span><br><span class="line">            ary[ary.length]=result[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return ary;</span><br><span class="line">    &#125;;</span><br><span class="line">console.log(reg.allExec(str));</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="正则的贪婪性"><a href="#正则的贪婪性" class="headerlink" title="正则的贪婪性"></a><code>正则的贪婪性</code></h4><p>正则每一次捕获的都是按照匹配的最长的结果捕获的，例如2符合正则，20也符合正则，默认捕获的是20.<br><code>如何解决正则的贪婪性</code>：在量词元字符后面添加一个？即可</p>
<p><code>?</code>:在正则中有很多的作用：<br>1.放在一个普通的元字符后面代表出现0-1次。例如/\d?/数字可能出现也可能不出现。<br>2.放在一个量词的元字符后面是取消捕获时候的贪婪性。<br>3.（?：）在分组中?:的意思是只匹配不捕获。</p>
<h4 id="字符串中的replace方法-捕获匹配正则的字符"><a href="#字符串中的replace方法-捕获匹配正则的字符" class="headerlink" title="字符串中的replace方法 捕获匹配正则的字符"></a>字符串中的replace方法 捕获匹配正则的字符</h4><p> replace原理：</p>
<blockquote>
<p>1、当replace方法执行，第一项传递一个正则<br>正则不加g：把当前字符串中第一个和正则匹配的结果捕获到，替换成新的字符<br>正则加g：把当前字符串中所有和正则匹配的内容都分别的捕获到，而且每一次捕获，都会把当前捕获的内容替换为新字符</p>
<p>2、当replace方法执行，第二个参数传递的是一个函数（回调函数）<br>首先用正则到字符串中进行查找匹配，匹配到一个符合规则的，就把传递的函数执行一次<br>不仅执行这个函数，而且还把正则本次捕获的结果（和执行exec捕获的结果一样：数组、大正则匹配、小分组匹配 都有）当做实参传递给这个函数（这样就可以在函数中获取这些值：而这些值就是正则每一次捕获的结果 ）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'my name is &#123;0&#125;,i am &#123;1&#125; years old,i can &#123;2&#125;!'</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;(\d+)\&#125;/g</span>;</span><br><span class="line">str.replace(reg, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//=&gt;传递的函数一共被执行三次</span></span><br><span class="line">    <span class="comment">//=&gt;console.log(arguments) 每一次匹配捕获到结果,不仅把这个方法执行了,而且还会把当前捕获的结果当做实参传递给这个函数(ARG)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第一次执行函数，获取的是ARG类数组</span></span><br><span class="line"><span class="comment">     *  0:'&#123;0&#125;' 本次大正则匹配的结果</span></span><br><span class="line"><span class="comment">     *  1:'0'   本次第一个小分组匹配的结果</span></span><br><span class="line"><span class="comment">     *  2:11    本次大正则匹配结果在字符串中的索引 index</span></span><br><span class="line"><span class="comment">     *  3:'my nam...' 原始字符串 input</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 和每一次执行exec实现捕获的结果非常类似</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//return xxx;//=&gt;每一次执行函数，函数中RETURN的结果，都相当于把本次大正则匹配的内容替换掉（原始字符串不变）</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="字符串中的match方法-捕获匹配正则的字符"><a href="#字符串中的match方法-捕获匹配正则的字符" class="headerlink" title="字符串中的match方法 捕获匹配正则的字符"></a>字符串中的match方法 捕获匹配正则的字符</h4><p> 使用字符串match捕获：</p>
<blockquote>
<p>1、如果正则加了修饰符g，执行一次match会把所有正则匹配的内容捕获到<br>2、如果没有加修饰符g，执行一次match只能把第一个匹配的结果捕获到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg =/\d+?/g;</span><br><span class="line">var str =&quot;d20a21l22i23&quot;;</span><br><span class="line">var ary =str.match(reg);</span><br><span class="line">console.log(ary);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><code>局限性</code>：在加了修饰符g的情况下，执行match方法只能把大正则匹配的内容捕获到，小正则捕获的内容是无法获取的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.match = function(reg)&#123;</span><br><span class="line">//this--&gt;str我们想操作的那个字符串--&gt;原型上的方法，里面的this都是我们想要操作的当前的实例</span><br><span class="line"></span><br><span class="line">var ary =[];</span><br><span class="line">var res =reg.exec(this);</span><br><span class="line">while(res)&#123;</span><br><span class="line">ary.pus(res[0]);</span><br><span class="line">res =reg.exec(this);</span><br><span class="line">&#125;</span><br><span class="line">return ary;</span><br><span class="line">&#125;;</span><br><span class="line">//str.match(reg);</span><br></pre></td></tr></table></figure>
<h4 id="使用test也可以实现正则的捕获"><a href="#使用test也可以实现正则的捕获" class="headerlink" title="使用test也可以实现正则的捕获"></a>使用test也可以实现正则的捕获</h4><blockquote>
<p>不管是正则的匹配还是正则的捕获，在处理时候的原理是没区别的：<code>从字符串的第一个字符向后查找，找到符合正则规则的字符，如果可以找到，说明正则和字符串匹配（test检测返回true、exec捕获返回捕获的内容），如果找到末尾都没有匹配的，说明正则和字符串不匹配（test检测返回false、exec捕获返回null）</code></p>
<p>如果正则设置了修饰符g，不管使用test还是exec中的任何方法，都会修改lastIndex值（下一次查找是基于上一次匹配结果的末尾开始查找的）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//=&gt;如果当前字符串和正则是匹配的，我们进行捕获</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;(\d+)\&#125;/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'my name is &#123;0&#125;~~'</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">    <span class="comment">//=&gt;reg.test(str) : true</span></span><br><span class="line">    <span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//=&gt;14</span></span><br><span class="line">    <span class="built_in">console</span>.log(reg.exec(str));<span class="comment">//=&gt;null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;(\d+)\&#125;/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'my name is &#123;0&#125;~~'</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">    <span class="comment">//=&gt;reg.test(str) : true</span></span><br><span class="line">    <span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//=&gt;0</span></span><br><span class="line">    <span class="built_in">console</span>.log(reg.exec(str));<span class="comment">//=&gt;['&#123;0&#125;','0'...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>使用test不仅可以找到匹配的内容，也能像exec一样把找到的内容获取到<br>test返回结果是 true/false，所以靠返回结果肯定不行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;(\d+)\&#125;/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'my name is &#123;0&#125;~~,i am &#123;1&#125; years old~~'</span>;</span><br><span class="line">reg.test(str);<span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//=&gt;0 获取到当前本次匹配内容中第一个小分组捕获的内容</span></span><br><span class="line"></span><br><span class="line">reg.test(str);<span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//=&gt;1 TEST可以实现捕获,但是每一次只能获取到当前本次匹配结果中,第N个分组捕获的内容 $1第一个分组 $2第二个分组 ...</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>只匹配不捕获：<br>//在当前一个分组中加了 ?: ，在正则检测匹配的时候，小分组可以起到自己应有的作用（例如：改变优先级…），但是在捕获的时候，遇到带?:的小分组，浏览器不会把当前这个分组中匹配的内容，单独去捕获了</p>
<p>var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(\d{2})(\d)(\d|X)$/;<br>reg.exec(‘130828199012040617’); //=&gt;[“130828199012040617”, “130828”, “1990”, “12”, “04”, “06”, “1”, “7”…]</p>
<p>var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(?:\d{2})(\d)(?:\d|X)$/;<br>reg.exec(‘130828199012040617’);//=&gt; [“130828199012040617”, “130828”, “1990”, “12”, “04”, “1”…]</p>
<p>var reg = /^-?(\d|([1-9]\d+))(.\d+)?$/;//=&gt;计算是第几个分组的时候，我们从左向右找 ( 即可.</p>
<h4 id="重置时间格式"><a href="#重置时间格式" class="headerlink" title="重置时间格式"></a>重置时间格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;2018-3-11 20:41:00&quot;,</span><br><span class="line">//第一步：将指定格式的时间字符中的年月日等信息村入一个数组</span><br><span class="line">reg =/^(\d&#123;4&#125;)[-/](\d&#123;1,2&#125;)[-/](\d&#123;1,2&#125;) +(\d&#123;1,2&#125;):(\d&#123;1,2&#125;):(\d&#123;1,2&#125;)$/g,</span><br><span class="line">ary =&#123;&#125;;</span><br><span class="line">str.replace(reg,function()&#123;</span><br><span class="line">ary = ([].slice.call(arguments)).slice(1,7);</span><br><span class="line">&#125;);</span><br><span class="line">//第二步：设定我们目标时间格式，把数组中对应的项替换成制定的区域内</span><br><span class="line">var resStr =&quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&quot;，</span><br><span class="line">reg =/&#123;(\d+)&#125;/g;</span><br><span class="line">resStr =resStr.replace(reg,function()&#123;</span><br><span class="line">var num = arguments[1],</span><br><span class="line">val = ary[num];</span><br><span class="line">val.length===1?val =&quot;0&quot;+val:void0;</span><br><span class="line">return val;</span><br><span class="line">&#125;);console.log（resStr）</span><br></pre></td></tr></table></figure>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><blockquote>
<p>数学函数：它属于对象数据类型  <code>typeof Math -&gt;&#39;object&#39;</code><br>Math对象中提供了很多操作数字的方法<br><code>console.dir(Math)</code><br>1.Math.abs 取绝对值<br>2.Math.ceil 向上取整</p>
<ol start="3">
<li>Math.floor 向下取整<br>4.Math.round 四舍五入<br>5.Math.random 获取(0,1)之间的随机小数<br>6.Math.max 获取一组值中的最大值<br>7.Math.min 获取一组值中的最小值<br>8.Math.PI 获取圆周率（π）<br>9.Math.pow 获取一个值的多少次幂<br>10.Math.sqrt  开平方</li>
</ol>
</blockquote>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>Date的基础知识</p>
<blockquote>
<p>Date是日期类，通过它可以对时间进行处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">var time = new Date();//=&gt;获取当前客户端本机时间（当前获取的时间不能作为重要的参考依据）</span><br><span class="line">//=&gt;获取的结果是一个日期格式的对象：Sun Oct 22 2017 15:58:40 GMT+0800 (中国标准时间)</span><br><span class="line">typeof new Date() -&gt;&apos;object&apos;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>time.getFullYear() //=&gt;获取四位整数年<br>time.getMonth() //=&gt;获取月（0~11代表1~12月）<br>time.getDate() //=&gt;获取日<br>time.getDay() //=&gt;获取星期（0~6代表周日~周六）<br>time.getHours() //=&gt;获取小时<br>time.getMinutes() //=&gt;获取分钟<br>time.getSeconds() //=&gt;获取秒<br>time.getMilliseconds() //=&gt;获取毫秒<br>time.getTime() //=&gt;获取当前日期距离’1970-01-01 00:00:00’的毫秒差</p>
</blockquote>
<blockquote>
<p>var time = new Date(‘2017-10-22’); //=&gt;当new Date中传递一个时间格式的字符串，相当于把这个字符串转换为标准的时间对象格式（转换完成后，就可以调取上面我们讲的那些方法了）<br>//=&gt;时间格式的字符串<br>‘2017-10-22’  (IE下识别不了)<br>‘2017/10/22’<br>‘2017/10/22 16:15:34’<br>1508659621314 (如果传递的是距离1970年的那个毫秒差，也是可以识别转换的，但是只能是数字，不能是字符串)</p>
</blockquote>
<h4 id="京东倒计时"><a href="#京东倒计时" class="headerlink" title="京东倒计时"></a>京东倒计时</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//=&gt; HTML</span><br><span class="line">&lt;!-- 京东倒计时抢购 --&gt;</span><br><span class="line">&lt;div class=&quot;time&quot;&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;</span><br><span class="line">京东秒杀&lt;br/&gt;距离本场活动结束的时间还有: &lt;span class=&quot;timeBox&quot; id=&quot;timeBox&quot;&gt;00:10:00&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//=&gt; JS</span><br><span class="line">/* 倒计时抢购*/</span><br><span class="line">function computed() &#123;</span><br><span class="line">var timeBox = document.getElementById(&apos;timeBox&apos;);</span><br><span class="line"></span><br><span class="line">var curTime = new Date(); // 电脑当前的时间</span><br><span class="line">var targetTime = new Date(&apos;2018/02/03 16:30&apos;); //我们自己给定的活动结束的时间;</span><br><span class="line">var areaTime = targetTime - curTime;</span><br><span class="line">//console.log(areaTime); //150621 毫秒数</span><br><span class="line"></span><br><span class="line">if (areaTime &lt; 0) &#123;</span><br><span class="line">timeBox.innerHTML = &apos;活动已经结束啦~&apos;;</span><br><span class="line">window.clearInterval(timer);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">/*得到的毫秒数 算出小时*/</span><br><span class="line">var hour = Math.floor(areaTime / (1000 * 60 * 60));</span><br><span class="line"></span><br><span class="line">/*从剩余的毫秒数中 算出分钟*/</span><br><span class="line">areaTime -= hour * 1000 * 60 * 60;</span><br><span class="line">/*减去小时占的毫秒数 剩下再去算分钟占的毫秒数*/</span><br><span class="line">var minutes = Math.floor(areaTime / (1000 * 60));</span><br><span class="line"></span><br><span class="line">/*从剩余的毫秒数中 算出秒*/</span><br><span class="line">areaTime -= minutes * 1000 * 60;</span><br><span class="line">var seconds = Math.floor(areaTime / 1000);</span><br><span class="line"></span><br><span class="line">/*补0的操作 只要小于10 就在前面补一个0*/</span><br><span class="line">hour &lt; 10 ? hour = &apos;0&apos; + hour : hour;</span><br><span class="line">minutes &lt; 10 ? minutes = &apos;0&apos; + minutes : minutes;</span><br><span class="line">seconds &lt; 10 ? seconds = &apos;0&apos; + seconds : seconds;</span><br><span class="line"></span><br><span class="line">timeBox.innerHTML = hour + &apos;:&apos; + minutes + &apos;:&apos; + seconds;</span><br><span class="line">&#125;</span><br><span class="line">computed();</span><br><span class="line">var timer = window.setInterval(computed, 1000); //每隔1s执行一次函数</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/变量提升/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/变量提升/" itemprop="url">变量提升</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-04T17:57:05+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><blockquote>
<p>在<code>当前作用域</code>中，JS代码自上而下执行<code>之前</code>，浏览器首先会把所有带<code>var/function</code>关键字的，进行提前的<code>声明(declare)/定义(defined)</code>，这种提前声明变量的机制，我们称之为<code>变量提升</code>。</p>
<ul>
<li>变量提升阶段：带var的只声明未定义。带function的声明和赋值都完成了。<ul>
<li>变量提升只发生在当前作用域，</li>
<li>在全局作用域下声明的函数或者变量是全局变量，同理在私有作用域声明的变量是私有变量，带var、function的才是声明</li>
<li>浏览器很懒做过的事情不会重复执行第二遍，当代码执行遇到创建函数这部分代码后直接的跳过即可，因为在变量提升阶段就已经完成函数的执行了</li>
<li>（函数执行）1.形成一个私有作用域。2.形参赋值。3.变量提升。<br>在es3和es5语法规法中只有全局作用域和函数执行的私有作用域（栈内存）其他的大括号不会形成栈内存。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="变量提升规律"><a href="#变量提升规律" class="headerlink" title="变量提升规律"></a>变量提升规律</h4><blockquote>
<p>1.只会对等号左边的进行变量提升（function作为值时不会变量提升）<br> 2.return后面的也不能变量提升，对return下面的还是要变量提升<br> 3.重名变量，不会重复声明，但可以多次被定义赋值，后面的定义会把前面的值覆盖。<br> 4.自执行函数本身的function不进行变量提升，定义+执行一起完成<br> 5.不管条件是否成立，对待var关键字的进行变量提升，但是function关键字，标准浏览器下声明，ie9以上浏览器是声明+定义<br>  <code>带var不带var的区别？</code><br>在全局作用域下声明一个变量，也相当于给window全局对象设置了一个属性，变量的值就是属性值（私有作用域中声明的私有变量和window没啥关系 ）</p>
<ul>
<li>带var进行变量提升<ul>
<li>不带var ：在全局作用域中，仅仅给全局对象设置了一个新的属性名把window省略了.</li>
<li>项目当中，目的是创建变量，最好不要省略var，更严谨。</li>
<li>全局变量和window中的属性存在映射机制。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><code>私有作用域中带var和不带var也有区别：</code><br> 带var的在私有作用域变量提升阶段都声明为私有变量和外界没有任何关系<br> 不带var不是私有变量会向他的上级作用域查找，看是否为上级的变量，不是的话就向上级作用域找，一直找到window为止，我们把这种查找机制叫做作用域链.也就是我们在私有作用域中操作的这个私有变量是一直操作别人的</p>
</blockquote>
<ul>
<li><code>不带var的查找顺序</code></li>
<li><p>1.看是不是私有变量（形参和私有作用域里声明的）是的话就是它<br>-2.若不是，则往上级作用域查找,查找过程叫做作用域链</p>
<p><code>什么是上级作用域？</code></p>
<blockquote>
<p>函数在哪里定义，则上级作用域就是谁<br><code>上级作用域只跟函数在哪定义有关，跟函数在哪里执行没有关系。</code></p>
</blockquote>
<h5 id="只对等号左边的进行赋值"><a href="#只对等号左边的进行赋值" class="headerlink" title="只对等号左边的进行赋值"></a>只对等号左边的进行赋值</h5><blockquote>
<p>=:赋值，左边是变量，右边都应该是值。（如果是个函数表达式，把函数变成一个值（空间地址）赋值给变量）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(fn);//undefined</span><br><span class="line">var fn=function()&#123;&#125;</span><br><span class="line">console.log(fn);//函数本身</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//=&gt;全局变量提升：var x; var y; var z; fn=AAAFFF000;</span><br><span class="line">var x = 10,</span><br><span class="line">    y = 20,</span><br><span class="line">    z = 30;</span><br><span class="line">function fn(x, y) &#123;</span><br><span class="line">    //=&gt;[私有作用域]</span><br><span class="line">    //=&gt;形参赋值：x=10 y=20 (x/y都是私有变量)</span><br><span class="line">    //=&gt;变量提升：var x(忽略的,已经存在x这个名字了)</span><br><span class="line">    console.log(x, y, z);//=&gt;z不是私有变量是全局变量 10 20 30</span><br><span class="line">    var x = 100;//=&gt;私有的x=100</span><br><span class="line">    y = 200;//=&gt;私有的y=200</span><br><span class="line">    z = 300;//=&gt;全局的z=300</span><br><span class="line">    console.log(x, y, z);//=&gt;100 200 300</span><br><span class="line">&#125;</span><br><span class="line">fn(x, y, z);//=&gt;FN执行传递的是实参(实参都是值) fn(10,20,30)</span><br><span class="line">console.log(x, y, z);//=&gt;10 20 300</span><br></pre></td></tr></table></figure>
<blockquote>
<p>真实项目中创建函数一般都用函数表达式<br>1.因为只能对等号左边进行变量提升，所以变量提升完成后，当前函数只是声明了，没有定义，想要执行函数，只能放在赋值的代码之后执行，放在代码前会报错<br>2.这种方法代码逻辑更加严谨，以后想要知道一个执行的函数做了什么功能，只需要向上查找定义的部分即可（不会存在定义的代码在执行下面的情况）<br>var fn = function sum(){<br>console.log(sum);//函数本身<br>console.log(1);<br>};<br>sum();//uncaught referenceerror:sum is not defined.sum在函数外面不能用在里面可以用<br>fn();</p>
</blockquote>
<h5 id="不管条件是否成立都要进行变量提升"><a href="#不管条件是否成立都要进行变量提升" class="headerlink" title="不管条件是否成立都要进行变量提升"></a>不管条件是否成立都要进行变量提升</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(num);//undefined</span><br><span class="line">console.log(fn);//undefined</span><br><span class="line">if(1===1)&#123;</span><br><span class="line">console.log(num);//undefined</span><br><span class="line">console.log(fn);//函数体本身</span><br><span class="line">var num =12;</span><br><span class="line">function fn ()&#123;&#125;</span><br><span class="line">console.log(num);//12</span><br><span class="line">console.log(fn);//函数体本身</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>老版本浏览器不是这样处理的：不管条件是否成立，都要进行变量提升（和新版不一样的地方，新版本function只是声明，老版本function依然是声明+定义）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;变量提升：没有</span></span><br><span class="line">f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;;</span><br><span class="line">g = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;;</span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//=&gt;[私有作用域]</span></span><br><span class="line">    <span class="comment">//变量提升：g=undefined (不管条件是否成立都要进行变量提升，但是新版本的浏览器只对函数进行声明)</span></span><br><span class="line">    <span class="keyword">if</span> (g() &amp;&amp; [] == ![]) &#123;<span class="comment">//=&gt;Uncaught TypeError: g is not a function</span></span><br><span class="line">        f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="built_in">console</span>.log(f());</span><br><span class="line"><span class="built_in">console</span>.log(g());</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>不管条件是否成立，判断体当中出现的var和function都会进行变量提升，但是新版本浏览器当中，function声明的变量只能提前声明不能定义了（函数是在判断体当中）<br>代码执行到判断地方<br>1）条件不成立;进入不到判断体当中赋值的代码执行不了，此事之前声明的变量或者函数依然是undefined。<br>2）条件成立：进入条件判断体中的第一件事情不是代码执行，而是把之前变量提升没有定义的函数首先定义了（进入到判断体中函数就定义了：迎合ES6中的块级作用域）<br>老版本浏览器不是这样处理的：不管条件是否成立，都要进行变量提升（和新版不一样的地方，新版本function只是声明，老版本function依然是声明+定义）</p>
</blockquote>
<h5 id="关于重名的处理"><a href="#关于重名的处理" class="headerlink" title="关于重名的处理"></a>关于重名的处理</h5><blockquote>
<p>在变量提升阶段，如果名字重复了，不会重新的进行声明，但是会重新的进行定义（后面赋的值会把前面赋的值给替换掉）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    var i = 1;</span><br><span class="line">    return function (n) &#123;</span><br><span class="line">        console.log(n + i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = fn();</span><br><span class="line">f(10);//-&gt;11</span><br><span class="line">fn()(10);//-&gt;11</span><br><span class="line">f(20);//-&gt;22</span><br><span class="line">fn()(20);//-&gt;21</span><br></pre></td></tr></table></figure></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/21/node-git基本应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/21/node-git基本应用/" itemprop="url">node&&git基本应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-21T04:24:40+08:00">
                2018-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="node-amp-GIT基础知识"><a href="#node-amp-GIT基础知识" class="headerlink" title="node &amp; GIT基础知识"></a>node &amp; GIT基础知识</h3><h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><ul>
<li>官网下载，一直下一步，最好下c盘。<br>或者：拷贝别人下载好的，</li>
<li>到我的电脑-属性-高级设置-环境变量-path-添加node的安装目录。</li>
<li>验证是否成功:win+R-&gt;cmd-&gt;node -version,npm -v能出现版本号代表安装成功，不能出现版本号，按照上一步配置环境变量即可。<h3 id="node基础概念"><a href="#node基础概念" class="headerlink" title="node基础概念"></a>node基础概念</h3>1.node并不是一门语言，他是一个工具或者一个运行环境基于v8引擎渲染和解析js的。</li>
<li>单线程</li>
<li>无阻赛i/o操作</li>
<li>事件驱动<br>…<br>之所以把node称为服务器语言是因为node给予操作服务器的能力：我们在服务器端安装node使用js服务器端需要处理的一些事情，最后把写好的js代码交给node环境运行即可</li>
</ul>
<p>2.在node环境当中把js代码执行</p>
<ul>
<li>repl命令（read-evaluate-print-loop）输入-求值-输出-循环</li>
<li><p>基于node xxx.js命令执行</p>
<ul>
<li>基于node执行我们需要先找到当前文件所在的文件夹，然后再这个目录下打开dos窗口，在窗口执行node xxx.js这样就相当于在node环境下把js文件中的代码执行了</li>
<li>如何在当前目录中打开dos窗口</li>
<li>1.基于dos命令中的cd一层层进入</li>
<li>2.在当前目录地址栏中输入cmd快速在当前目录打开</li>
<li>3.shift+鼠标右键，在此处打开命令窗口</li>
</ul>
</li>
<li><p>基于wb这类编辑工具直接执行</p>
</li>
</ul>
<p>3.常用DOS命令</p>
<ul>
<li><code>ping www.baidu.com -t</code></li>
<li>测试网速，然后<code>Ctrl+c</code>结束当前运行的操作</li>
<li><code>exit</code>：退出当前窗口</li>
<li><code>ipconfig -all</code>   ：查看当前电脑的物理地址、IP地址、子网掩码、DNS等信息</li>
<li><code>cls</code>；清屏</li>
<li><code>cd</code>:进入指定的文件目录，（windows电脑需要先进入对应的磁盘）</li>
<li><code>cd ../</code>:返回上级目录</li>
<li><code>cd .</code>:当前目录</li>
<li><code>cd /</code>:根目录</li>
<li><code>dir</code>:查看当前目录下的文件</li>
<li><code>mkdir</code>:创建文件夹</li>
<li><code>copy con xxx.xx</code>:创建文件并且给文件中输入内容，输入完成后用<code>Ctrl+c</code>结束并保存</li>
<li><code>del xxx.xx</code>:删除文件</li>
<li><code>rmdir</code>:删除文件夹</li>
</ul>
<h3 id="npm模块管理"><a href="#npm模块管理" class="headerlink" title="npm模块管理"></a>npm模块管理</h3><p>安装完node后基本上自带npm模块管理器<br>我们需要一个第三方模块，或者模块插件，或者类库，或者框架，需要提前下载安装才可以使用，百度搜索找到下载地址，然后基于浏览器下载即可（资源比较混乱不好搜索）<br>也可以基于npm等第三方包管理器下载（yarn/bower这些都是第三方模块管理器）<br>1.npm下载的资源都是在<a href="http://www.npmjs.com/" target="_blank" rel="noopener">http://www.npmjs.com/</a>中下载的<br><code>npm install xxx</code>:把资源或者第三方模块下载到当前目录下<br><code>npm install xxx -g(--global)</code>:把资源或者第三方模块安装到全局环境下，可以基于命令来操作一些事情<br>卸载npm uninstall xxx/xxx -g:从本地或者全局卸载</p>
<blockquote>
<p>基于npm安装的一些细节点：</p>
<ul>
<li>需要联网</li>
<li>下载成功后当前目录中多增加一个node_modules文件夹，在这个文件夹中找到我们安装的模块</li>
<li>一般来说下载下来的内容包括源码和最后供开发者使用的压缩版本。</li>
</ul>
</blockquote>
<blockquote>
<p>2.解决下载慢的问题</p>
<ul>
<li>基于npm切换到国内下载源（一般是淘宝镜像）<ul>
<li>首先安装nrm而且是把他安装到全局环境下，因为我们要使用命令。</li>
<li><code>npm install nrm -g</code></li>
<li>安装完我们就可以使用nrm命令</li>
<li><code>nrm ls</code>查看当前可用源</li>
<li><code>nrm use xxx</code>使用某个可用源</li>
</ul>
</li>
<li>也可以基于yarn来安装管理<ul>
<li>首先安装yarn，安装到全局，然后基于yarn安装我们需要的模块</li>
<li><code>npm install yarn -g</code></li>
<li><code>yarn add xxx</code></li>
<li><code>yarn remove xxx</code></li>
<li>基于yarn安装只能安装到本地不能安装到全局</li>
</ul>
</li>
<li>基于cnpm淘宝镜像来处理</li>
</ul>
</blockquote>
<blockquote>
<p>3.解决安装版本的问题</p>
<ul>
<li>首先查看当前模块的历史版本信息<ul>
<li><code>npm view jQuery&gt;jquery.version.json</code>:把当前模块的历史版本信息输出到具体的某个文件夹（文件名是自己取得）</li>
<li>安装指定的版本模块</li>
<li><code>yarn add jquery@1.11.3:npm</code> 和yarn都是这样来指定安装具体版本模块</li>
</ul>
</li>
</ul>
</blockquote>
<p>1.bower是从github下载安装<br>2.安装less、babel-cli …</p>
<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><blockquote>
<p>一个提供代码管理的公共平台我们以及众多开发者会把自己的生产的组件、类库、插件、框架等托管到这个平台供别人下载使用和研究<br>在github中我们可以创建仓库来管理自己的项目文件，而github支持开发者通过git操作，把本地的项目代码推送到指定的仓库，它还提供静态web页面的发布<br>在国内有一个和github类似的网站：coding,和github类似，也是提供代码管理的平台，但资源少。</p>
</blockquote>
<h3 id="git的基础知识"><a href="#git的基础知识" class="headerlink" title="git的基础知识"></a>git的基础知识</h3><ul>
<li>git是一个分布式代码版本管理控制系统</li>
<li>记录当前产品代码的所有版本信息（历史修改信息）而且方便快速回退到某一个具体版本，</li>
<li>方便团队协作开发，能够检测代码冲突能够合并代码等<br>svn:集中式版本控制系统<br>git：分布式版本控制系统</li>
</ul>
<blockquote>
<p>分布式和集中式区别：<br>[集中式]：想要做历史记录的查看或者备份必须链接到中央处理器才可以（需要联网）<br>处理速度没有Git快<br>[分布式]：每个开发者本地都是一个单独的仓库，在自己的仓库中就可以完成历史版本的记录和查看（不需要联网）<br>Git处理速度更快。</p>
</blockquote>
<h3 id="git操作步骤"><a href="#git操作步骤" class="headerlink" title="git操作步骤"></a>git操作步骤</h3><p>步骤：<br>1.先在GitHub上创建一个远程仓库<br>2.在本地创建一个文件夹初始化git仓库 <code>git init</code><br>3.本地仓库和远程仓库关联起来<code>git remote add origin</code>[可以自己起名字] 远程仓库的网络地址,移除关联是<code></code>git remote remove xxx<code>4.把本地仓库的内容提交到暂存区</code>git add .<code>5.把本地仓库的内容以及注释提交到历史区</code>git commit -m<code>&#39;注释内容&#39;
6.把远程仓库的内容先拉到本地仓库，保持远程仓库和本地仓库同步</code> git pull origin master –allow-unrelated-histories<code>7.提交到远程仓库</code> git push origin master `</p>
<h3 id="提交本地项目的另外一种方式："><a href="#提交本地项目的另外一种方式：" class="headerlink" title="提交本地项目的另外一种方式："></a>提交本地项目的另外一种方式：</h3><p>1.<code>git clone 远程仓库地址 本地仓库名（可以不写）</code>的方式把远程仓库克隆到本地<br>代替了:<br><code>git init</code>在本地创建了git仓库<br><code>git remote add origin [地址]</code>本地仓库和远程仓库关联了起来<br><code>git pull origin master</code>把远程仓库的内容拉取到了本地仓库<br>2.进入克隆的本地仓库 cd [本地仓库名]<br>3.<code>git add.</code><br>4.<code>git commit -m&#39;注释&#39;</code><br>5.<code>git push origin master</code>提交到远程仓库</p>
<h3 id="提交项目"><a href="#提交项目" class="headerlink" title="提交项目"></a>提交项目</h3><p>登录GitHub<br><a href="https://github.com/zfpx/201801JS.git" target="_blank" rel="noopener">https://github.com/zfpx/201801JS.git</a>  黏贴到地址栏回车<br>点fork按钮，相当于把那个仓库克隆一份到我的仓库<br>git clone 刚刚克隆的仓库的地址 把从老师那fork过来的 远程仓库克隆到本地<br>cd 201801JS  到当前本地仓库地址<br>git add .添加到暂存区<br>git commit -m添加到历史区<br>git push origin master上传到自己的复制的远程仓库（根目录应该是本地仓库地址）</p>
<p>New pull request发出新请求<br>Create pull request  申请并入</p>
<p>主管做的事情merge pull request 或者close pull request</p>
<blockquote>
<p>webstrom关联<br>打开有关联通道文件夹，在子目录下创建文件，编辑后，点击菜单栏的VCS中的git-&gt;add，再次点击VCS中的git-&gt;commit,commit and push ,push.</p>
</blockquote>
<h3 id="Linux操作系统常用命令"><a href="#Linux操作系统常用命令" class="headerlink" title="Linux操作系统常用命令"></a>Linux操作系统常用命令</h3><blockquote>
<ul>
<li><code>ls</code>查看当前目录下的文件<ul>
<li><code>-l</code>查看详细信息</li>
<li><code>-a</code>查看隐藏文件</li>
<li><code>-la</code>同时具备以上特定</li>
</ul>
</li>
<li><code>clear</code>清屏</li>
<li><code>cd</code>目录切换<ul>
<li><code>cd../</code>返回上级目录</li>
<li><code>cd./</code>返回当前目录</li>
<li><code>cd</code>/返回根目录</li>
<li><code>cd xxx</code>进入指定文件夹</li>
<li><code>cd E:</code>进入到指定的磁盘</li>
</ul>
</li>
<li><code>mkdir</code>创建文件夹</li>
<li><code>touch</code> 创建一个空文件<ul>
<li>可以创建无文件名的文件。例如touch .gitignore/touch .babelrc…</li>
<li>在电脑旁隐藏文件后缀名的情况下。我们不至于创建出1.txt.txt这样重复后缀名的文件。</li>
</ul>
</li>
<li><code>vi</code>向指定文件中插入内容例如：vi 1.txt<ul>
<li>首先进入命令窗口模式</li>
<li>我们先按<code>i</code>，进入到插入内容模式</li>
<li>编辑要写的内容</li>
<li>按<code>esc</code>键，再按<code>：</code>键，再按<code>wq</code>(保存并退出)</li>
<li>如果按q!（强制退出，新输入的内容不保存）<br>-echo xxx&gt;1.txt  把xxx内容放到1.txt文件中，如果没有这个文件则创建这个文件（新存放的内容会替换原有的内容）<br>-echo xxx &gt;&gt;1.txt 新的内容会追加到原有内容的后面</li>
</ul>
</li>
<li><code>cat</code>查看文件中的内容</li>
<li><code>cp</code>拷贝文件</li>
<li><code>rm</code>删除文件<ul>
<li><code>-r</code>递归删除（把当前文件夹中的所有的后代元素也都遍历到删除）</li>
<li><code>-f</code>强制删除</li>
<li><code>-rf</code>一旦rf后，没有办法还原回来，所以删除要慎重</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h3><blockquote>
<p>安装完成Git后。我们最好先把一些基础信息配置一下<br><code>git config -l</code>查看当前本级Git的配置清单<br>相对比较重要的配置g：user.name/user.email,每一次提交的时候我们需要知道谁提交的。<br><code>$git config --global user.name xxx
$git config --global user.email xxx</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">切换账号:git config credential.helper &apos;&apos;</span><br><span class="line"></span><br><span class="line">保存账号git config credential.helper store</span><br></pre></td></tr></table></figure>
<h3 id="Git工作原理和流程"><a href="#Git工作原理和流程" class="headerlink" title="Git工作原理和流程"></a>Git工作原理和流程</h3><p>“<code>git工作流程</code>”<br>一个Git仓库分为三个区域：<br>1.工作区：平时写代码的地方。<br>2.暂存区：把一些写好的代码暂时存储的地方。<br>3.历史区：生成一个个版本记录的地方。<br><code>&quot;创建Git仓库&quot;</code><br>在电脑的某一个文件夹中<br>1）右键-&gt;git bash here -&gt;在窗口执行<code>git init</code>.<br>2) 在windows dos窗口中执行，还是执行相同的命令执行完成后会在当前电脑指定文件夹中生成一个 .git 文件，证明当前文件夹就是一个本机独立的git版本控制仓库<br>一个项目目录下，我们一般会有以下这样的文件<br><code>.git</code>:在当前项目中创建git仓库生成的文件（很重要）<br><code>.idea</code>:使用WS开发，默认生成的文件，记录WS的一些信息（没用）<br><code>.gitignore</code>:我们一般会手动的在当前项目中创建一个后缀名是gitignore的文件，这个文件中记录了每一次git提交时候忽略不管的文件或者文件夹（ws中可以创建这个文件）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># dependencies</span><br><span class="line">node_modules</span><br><span class="line"></span><br><span class="line"># testing</span><br><span class="line">/coverage</span><br><span class="line"></span><br><span class="line"># production</span><br><span class="line">/build</span><br><span class="line"></span><br><span class="line"># misc</span><br><span class="line">.DS_Store</span><br><span class="line">.env.local</span><br><span class="line">.env.development.local</span><br><span class="line">.env.test.local</span><br><span class="line">.env.production.local</span><br><span class="line"></span><br><span class="line">npm-debug.log*</span><br><span class="line">yarn-debug.log*</span><br><span class="line">yarn-error.log*</span><br><span class="line"></span><br><span class="line"># webStorm</span><br><span class="line">.idea</span><br></pre></td></tr></table></figure></p>
<p><code>README.md</code>:这个文件选择性增加，通过这个文件可以对当前的项目进行详细的描述（使用markdown编写）<br>在真正的项目中，一般都是需要团队协作开发的，也就是都会存在一个中央远程仓库，而我们操作的步骤如下：</p>
<p>我们可以在本地继续开发，如果需要把开发的内容同步到远程仓库上，还是按照之前的老步骤操作即可<br><code>git add -A</code><br><code>git commit -m’备注信息’</code><br><code>git push origin master</code></p>
<p><code>把工作区中的内容提交到暂存区</code><br><code>git add xxx</code>把指定的文件提交到暂存区<br><code>git add./git add -A</code>把所有修改的文件都提交到暂存区<br><code>git statu</code>查看当前工作区中文件的状态。<br>显示<code>红色</code>还没有提交到暂存区。<br>显示<code>绿色</code>还没有提交到历史区。<br><code>把暂存区的内容统一提交到历史区</code><br>提交到历史区的内容，会生成相关的版本和历史记录，以后如果想回滚到某一次的代码，可以使用git命令迁出对应的版本即可<code>git commit -m&#39;xxx&#39;</code>:把暂存区的内容提交到历史区（-m后面的内容都是对本次提交新版本的说明）</p>
<h3 id="把本地的版本代码推送到中央仓库上"><a href="#把本地的版本代码推送到中央仓库上" class="headerlink" title="把本地的版本代码推送到中央仓库上"></a>把本地的版本代码推送到中央仓库上</h3><p>1）让本地仓库和远程仓库建立连接通道<br><code>git remote add [name:一般都叫做origin] [远程仓库地址]</code><br><code>git remote rm [name]</code><br><code>git remote update [name]</code><br><code>git remote -v</code>查看当前本地仓库所有的链接通道<br>2）把本机仓库代码和版本信息推送（拉取）到远程仓库上<br><code>git push origin master</code>推送<br><code>git pull origin master</code>拉取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本地仓库和远程仓库不一致时可以先拉后推</span><br><span class="line">`git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure></p>
<h3 id="无分支模式下的团队协作"><a href="#无分支模式下的团队协作" class="headerlink" title="无分支模式下的团队协作"></a>无分支模式下的团队协作</h3><p>作为开发者每天来的第一件事或提交代码之前都要先pull一下<br>[<code>如果远程仓库和本地仓库不是同一个文件或同一行代码从冲突</code>]<br>git会自动会依赖于fast-forward模式进行合并<br>自动合并后，我们需要重新提交即可git add/git commit/push…<br>[<code>同一个文件的同一行代码冲突</code>]<br>找到冲突的文件，留下自己想要的代码<br>不管之前是否commit过，都要重新commit，然后push即可。</p>
<h3 id="单独分支管理"><a href="#单独分支管理" class="headerlink" title="单独分支管理"></a>单独分支管理</h3><ul>
<li>1.每天第一件事就是创建一个dev分支，并且切换到这个分支上<ul>
<li>2.正常的开发代码，把每天开发的任务都要先提交到自己的分支上</li>
<li>3.提交到远程仓库上<br>把本地自己分支中的内容，合并到本地自己的master分支下<br>把本地创建的分支删除（可以不删除，但是有的公司不希望远程出现分支，或者避免开发人员的分支冲突，提交之前都要把自己创建的分支删除掉）</li>
<li>4.和第一种只使用master分支一样了，把本地最新合并的master分支代码，提交到远程仓库的master分支下（冲突合并即可）。</li>
</ul>
</li>
</ul>
<p>操作分支的基础命令<br><code>$git branch</code> 查看现有的分支<br><code>$git branch xxx</code>创建一个新的分支<br><code>$git checkout xxx</code>切换到某个分支上<br><code>$git checkout -b xxx</code>创建一个新分支并且切换到这个分支上<br><code>$git branch -D xxx</code>删除某个分支（一定要切换到其他分支上才可以删除当前分支）<br><code>$git merge xxx</code>合并分支内容<br><code>$git log --graph /--oneline</code><br>在有分支的情况下，可以更清楚查看分支的提交和合并内容</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tiandali</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tiandali</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
