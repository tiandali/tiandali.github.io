<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="tiandali">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="tiandali">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tiandali">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>tiandali</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">tiandali</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/22/盒子模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/盒子模型/" itemprop="url">盒子模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-22T01:10:35+08:00">
                2018-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="js盒子模型"><a href="#js盒子模型" class="headerlink" title="js盒子模型"></a>js盒子模型</h3><p>提供一些属性和方法用来描述当前盒子的样式的</p>
<h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><p><code>clientWidth/clientHight</code></p>
<blockquote>
<p>当前盒子可视区域的宽度和高度<br>可视区域：内容的宽高+padding<br>clientWidth=width+padding(left/right)<br>clientHight=height+padding(top/bottom)</p>
</blockquote>
<p>和内容是否已出以及我们是否设置了overflow:hidden;没有关系<br><code>clientTop</code>和<code>clientLeft</code><br>clientTop:盒子上边框的高度。<br>clientLeft：盒子左边框的宽度。<br>获取的结果就是border-width的值</p>
<blockquote>
<p>通过js盒子模型属性获取的结果是不带单位的，而且只能是整数（他会自动四舍五入）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取当前页面一屏幕的宽度</span><br><span class="line">document.documentElement.clientWidth||document.body.clientWidth</span><br><span class="line"></span><br><span class="line">获取当前页面一屏幕的高度</span><br><span class="line">document.documentElement.clientHeight||document.body.clientHeight</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h4><p><code>offsetWidth</code>和<code>offsetHeight</code><br>在clientWidth和clientHeight的基础上<code>加上</code>盒子的<code>边框</code>即可<br><code>offsetWidth=width+padding(左右)+border（左右）=clientHeight+border(左右)</code><br><code>在真实项目中想获取一个盒子的宽度和高度，我们一般用offsetWidth而不是clientwidth，border也是盒子的一部分</code></p>
<p><code>offsetParent</code>：参照物<br><code>offsetLeft</code>：左偏移（）<br><code>offsetTop</code>：上偏移<br>offset系列（与溢出的内容无关）<br>偏移：<br>1.当前元素（边框以外）到参照物（边框以内）的距离<br>2.获取偏移量，当前元素不一定要设成定位元素。<br>3.当前元素找参照物的方式跟css里找参照物一样<br>4.默认的参照物是body，但实际上到窗口左边和上边的距离，body是文档的代理人，对body不要设置margin，float等属性<br>5.其他元素margin，float也会造成影响</p>
<h4 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h4><p><code>scrollWidth</code>和<code>scrollHeight</code></p>
<blockquote>
<p>没有内容溢出的情况：获取的结果和clientWidth和clientHeight是一样的<br>有内容溢出的情况：真实内容的宽度或者高度（包含溢出的内容），加上左padding或者上padding。<code>获取的结果是一个约等于值，每个浏览器由于对行高或者文字的渲染不一样，结果也是不一样的，是否设置了overflow对最后获取的结果也有影响</code><br><img src="./1522516108981.png" alt="Alt text"><br><code>scrollLeft</code>：横向滚动条卷出去的宽度<br><code>scrollTop</code>：纵向滚动条卷出去的高度。<br>最大宽、高  等于= 整个文档（scrollwidth/height）宽、高，减去一屏的(clientwidth/height)宽、高<br>   scrollTop=scrollheight-clientheight<br>   <code>scrollLeft</code>、<code>scrollTop</code>是13个js盒子模型相关属性里唯一<code>两个可以赋值的属性</code>，其他的11个属性只能获取不能赋值,</p>
</blockquote>
<h4 id="通过js盒模型属性获取值的特点"><a href="#通过js盒模型属性获取值的特点" class="headerlink" title="通过js盒模型属性获取值的特点"></a>通过js盒模型属性获取值的特点</h4><blockquote>
<ul>
<li>1.若赋值是浮点数取得是整数部分,不会四舍五入</li>
<li>2.13个js盒子模型获取的值都不带单位</li>
<li>3.获取的结果都是复合样式值（好几个元素的样式组合在一起的值），如果只想获取单一样式值（例如只想获取padding）我们的盒子模型属性就操作不了了（这不能说没有用，真实项目中有时候我们就是需要获取组合的值来完成一些操作）</li>
</ul>
</blockquote>
<h3 id="在js中获取元素具体的样式值"><a href="#在js中获取元素具体的样式值" class="headerlink" title="在js中获取元素具体的样式值"></a>在js中获取元素具体的样式值</h3><blockquote>
<p>通过js盒子模型属性获取的结果都是盒子的组合样式值，不能直接获取某一个具体样式值，例如就想获得左padding<br><code>curEle.style.xxx</code><br>获取当前元素所有写在<code>行内</code>样式上的样式值<br>特殊：只有把样式写在行内样式上，才可以通过这种办法获取到（写在其他地方的样式获取不到）所以这种办法在真实项目中使用非常少。<br><code>window.getComputedStyle</code>/<code>currentStyle</code><br>只要当前元素在页面中显示出来我们就可以获取样式值，也就是获取所有经过浏览器计算过的样式<br>window.getComputedStyle:适用于标准浏览器，低版本IE浏览器不兼容，所以用curEle.currentStyle来获取需要的样式值。</p>
</blockquote>
<h3 id="封装css"><a href="#封装css" class="headerlink" title="封装css"></a>封装css</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">let utils = (function () &#123;</span><br><span class="line">    let getCss = function getCss(curEle, attr) &#123;</span><br><span class="line">        if (&apos;getComputedStyle&apos; in window) &#123;</span><br><span class="line">            let val = window.getComputedStyle(curEle, null)[attr];</span><br><span class="line">            let reg = /^-?\d+(\.\d+)?(px|rem|em|pt)?$/i;</span><br><span class="line">            reg.test(val) ? val = parseFloat(val) : null;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line">        //=&gt;throw new SyntaxError：抛出一个错误(语法错误),让浏览器崩溃,不在继续执行JS</span><br><span class="line">        throw new SyntaxError(&apos;您的浏览器版本过低，请升级到最新版本，谢谢配合！！&apos;);</span><br><span class="line">    &#125;;//获得</span><br><span class="line">    let setCss = function (curEle, attr, value) &#123;</span><br><span class="line">        /*细节处理：1.如果需要考虑IE6-8，透明度这个样式在低版本浏览器中不是使用opacity，而是filter（两套都要设置）*/</span><br><span class="line">        //2.</span><br><span class="line">        if (attr === &apos;opacity&apos;) &#123;</span><br><span class="line">            curEle.style.opacity = value;</span><br><span class="line">            curEle.style.filter = `alpha(opacity=$&#123;value * 100&#125;)`;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!isNaN(value)) &#123;</span><br><span class="line">            let reg = /^(width|height|fontSize|((margin|padding)?(top|left|right|bottom)?))$/i;</span><br><span class="line">            reg.test(attr) ? value += &apos;px&apos; : null;</span><br><span class="line">        &#125;</span><br><span class="line">        curEle[&apos;style&apos;][attr] = value;</span><br><span class="line">    &#125;;//设置单一属性</span><br><span class="line">    let setGroupCss = function (curEle, options = &#123;&#125;) &#123;</span><br><span class="line">        //遍历传递的options,有多少键值对，就循环多少次</span><br><span class="line">        for (let attr in options) &#123;</span><br><span class="line">            if (!options.hasOwnProperty(attr)) break;</span><br><span class="line">            //options:传递进来的需要修改的样式对象</span><br><span class="line">            //attr：每一次遍历到的几个中的某一项（要操作的属性名）</span><br><span class="line">            setCss(curEle, attr, options[attr])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;//批量设置多个属性</span><br><span class="line">    let css = function (...arg) &#123;</span><br><span class="line">        let len = arg.length;</span><br><span class="line">        fn = getCss;</span><br><span class="line">        len &gt;= 3 ? fn = setCss : null;</span><br><span class="line">        len === 2 &amp;&amp; (arg[1] instanceof Object) ? fn = setGroupCss : null;</span><br><span class="line">        return fn(...arg);</span><br><span class="line">    &#125;;//汇总前三个方法</span><br><span class="line">    let offset = function (curEle) &#123;</span><br><span class="line">        let curLeft = curEle.offsetLeft,</span><br><span class="line">            curTop = curEle.offsetTop;</span><br><span class="line">        p = curEle.offsetParent;</span><br><span class="line">        while (p.tagName !== &apos;BODY&apos;) &#123;</span><br><span class="line">            curLeft += p.clientLeft;</span><br><span class="line">            curLeft += p.offsetLeft;</span><br><span class="line">            curTop += p.clientTop;</span><br><span class="line">            curTop += p.offsetTop;</span><br><span class="line">            p = p.offsetParent;//=&gt;基于当前找到的父参照物继续向上查找</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            top: curTop,</span><br><span class="line">            left: curLeft</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;//当前元素到页面边界的偏移量</span><br><span class="line">    let winHandle=function (attr,value) &#123;</span><br><span class="line">        if(typeof value!==&apos;undefined&apos;)&#123;</span><br><span class="line">            //设置盒子模型的属性值：scrolltop、scrollleft</span><br><span class="line">            document.documentElement[attr]=value;</span><br><span class="line">            document.body[attr]=value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        return document.documentElement[attr]||document.body[attr];</span><br><span class="line">    &#125;;//操作浏览器的盒子模型属性需要写两套（HTML和body）这个方法兼容处理了</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        css,</span><br><span class="line">        offset,</span><br><span class="line">        winHandle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/22/H5、css3常用标签/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/H5、css3常用标签/" itemprop="url">H5、css3常用标签</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-22T01:09:55+08:00">
                2018-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTML5、CSS3"><a href="#HTML5、CSS3" class="headerlink" title="HTML5、CSS3"></a>HTML5、CSS3</h3><blockquote>
<p>HTML5新增标签<br>|标签|描述|<br>|–|–|<br>|header|头部|<br>|footer|尾部|<br>|nav|导航|<br>|section|区分大模块|<br>|aside|侧边栏|<br>|article|文章|<br>|figure|配图|<br>|figcaption|配图说明|<br>|video|视频|<br>|audio|音频|&lt;<br>|main|主体|<br>| video 视频| audio音频|<br>|–|–|<br>| src=”” 视频路径| autoplay 自动播放|<br>|controls 是否显示控件|loop 循环播放|&lt;<br>|–|–|<br>|表单|功能|<br>|–|–|<br>|input type=”number”|数字|<br>|input type=”tel”|电话号码输入框|<br>|input type=”url”|输入URL地址|<br>|input type=”range”|特定范围内的数值选择器（通过拖动滚动条改变一定范围内的数字）|<br>|input type=”search”|搜索输入框|<br>|input type=”email”|邮箱|<br>|input type=”color”|颜色选取器|<br>|input type=”datetime”|显示完整日期和时间UTC标准时间|<br>|input type=”datetime”|显示完整日期和时间|<br>|input type=”time”|显示时间|<br>|input type=”month”|显示月|<br>|input type=”week”|显示周|<br>|input type=”file”|上传文件|&lt;<br>|input type=”text”|”placeholder”输入框占位符，常用作输入提示，在光标聚焦时，占位符自动消失|<br>|input type=”text”|”autocomplete”是否保存用户输入值，默认on，关闭提示选择off|<br>|input type=”text”|”autofocus”自动聚焦|<br>|input type=”text”|”required”:此项必填不能为空|<br>|input type=”text”|”Pattern”:正则验证pattern=”\d{1,5}”|<br>from属性只要加上from属性，表单元素可以放到页面的任意位置。<br>formnovalidate和novalidatae他俩都表示不需要验证表单直接提交，novalidate用于form标签；formnovalidate用于submit类型的提交按钮。<br>表单验证</p>
<ul>
<li>validity对象，通过下面的valid可以查看验证是否通过</li>
<li>oTex.addEvectListener(“invalid”,fn1,false);</li>
<li>valid:验证不通过时返回false</li>
<li>valueMissing:输入值为空时</li>
<li>typeMismatch：控件值与预期类型不匹配</li>
<li>patternMismatch:输入值不满足pattern正则</li>
<li>customError：不符合自定义验证</li>
<li>setCustomValidity();自定义验证</li>
</ul>
</blockquote>
<h4 id="input类型"><a href="#input类型" class="headerlink" title="input类型"></a>input类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- input表单元素的类型</span><br><span class="line">text  文本类型</span><br><span class="line">password  密码类型</span><br><span class="line">button 按钮类型</span><br><span class="line">submit 提交按钮类型</span><br><span class="line">reset 重置按钮类型</span><br><span class="line">file 文件类型</span><br><span class="line">radio 单选框类型</span><br><span class="line">checkbox 复选框类型</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!-- 文本类型 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--密码类型--&gt;</span><br><span class="line">&lt;input type=&quot;password&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 按钮类型 --&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;百度一下&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交按钮 --&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 重置按钮--&gt;</span><br><span class="line">&lt;input type=&quot;reset&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--文件类型--&gt;</span><br><span class="line">&lt;input type=&quot;file&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--多选框类型--&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot;&gt; 自动登录&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot;&gt; 敲代码&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot;&gt; 滑板&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot;&gt; 健身&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--单选框--&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 男&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 女&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 性别不详&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;image&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>以上为常用HTML5标签<br>在之前的HTML页面中，大家基本上都是用了Div+CSS的布局方式。而搜索引擎去抓取页面的内容的时候，它只能猜测你的某个Div内的内容是文章内容容器，或者是导航模块的容器，或者是作者介绍的容器等等。也就是说整个HTML文档结构定义不清晰，HTML5中为了解决这个问题，专门添加了：页眉、页脚、导航、文章内容等跟结构相关的结构元素标签。</p>
<p>1.header<br>标签定义文档的页眉,通常是一些引导和导航信息，它不局限写在网页头部，也可以写在网页内容里面。通常<code>&lt;header&gt;</code>标签至少包含（但不局限于）一个标题标记<code>(&lt;h1&gt;~&lt;h6&gt;)</code>,还可以包括<code>&lt;hgroup&gt;</code>标签，还可以包括表格内容、标识、搜索表单、<code>&lt;nav&gt;</code>导航等；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;</span><br><span class="line">    &lt;hgroup&gt;</span><br><span class="line">        &lt;h1&gt;网站标题&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;网站副标题&lt;/h2&gt;</span><br><span class="line">    &lt;/hgroup&gt;</span><br><span class="line">&lt;/header&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>2.nav<br>nav标签代表页面的一个部分,是一个可以作为页面导航的链接组，其中的导航元素链接到其他页面或者当前页面的其他部分，使html代码在语义化方面更加精确，同时对于屏幕阅读器等设备的支持也更好；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;珠峰培训首页&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;node培训课程&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;html5培训课程&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;珠峰论坛&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>3.section<br>    section标签，定义文档中的节。比如章节、页眉、页脚或文档中的其他部分。一般用于成节的内容，会在文档流中开始一个新的节。它用来表现普通的文档内容或应用区块，通常由内容及其标题组成。但section元素标签并非一个普通的容器元素，它表示一段专题性的内容，一般会带有标题。</p>
</blockquote>
<blockquote>
<p> 当我们描述一件具体的事物的时候，通常鼓励使用artice来代替section;当我们使用section时，仍然可以使用h1来作为标题，而不用担心它所处的位置，以及其它地方是否用到;当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div元素而非section;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">    &lt;h1&gt;section是什么？&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;是一个独立的章节&lt;/p&gt;</span><br><span class="line">    &lt;article&gt;</span><br><span class="line">       &lt;h2&gt;关于section&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;section的介绍&lt;/p&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line"> &lt;/section&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>4.article<br>article是一个特殊的section标签，它比section具有更明确的语义，它代表一个独立的，完整的相关内容块，可独立于页面其他内容使用。例如一篇完整的论坛帖子，一篇博客文章，一个用户评论等等。一般来说，article会有标题部分(通常包含在header内),有时也会包含footer。article可以嵌套，内层的article对外层的article标签有隶属关系。例如，一篇博客文章，可以用article显示，然后一些评论可以以article的形式嵌入其中;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;article&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;hgroup&gt;</span><br><span class="line">            &lt;h1&gt;这是一篇介绍HTML 5结构标签的文章&lt;/h1&gt;</span><br><span class="line">            &lt;h2&gt;HTML 5的革新&lt;/h2&gt;</span><br><span class="line">       &lt;/hgroup&gt;</span><br><span class="line">       &lt;time datetime=&quot;2016-11-18&quot;&gt;2016.11.18&lt;/time&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;p&gt;文章内容详情&lt;/p&gt;</span><br><span class="line"> &lt;/article&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>5.aside<br>aside标签用来装载非正文的内容，被视为页面里面一个单独的部分。它包含的内容与页面的主要内容是分开的，可以被删除，而不会影响网页的内容、章节或是页面所要传达的信息。例如广告，成组的链接，侧边栏等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aside&gt;</span><br><span class="line">     &lt;h1&gt;简介&lt;/h1&gt;</span><br><span class="line">     &lt;p&gt;我是简介内容，嘿嘿&lt;/p&gt;</span><br><span class="line"> &lt;/aside&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>6.footer<br>footer标签定义section或document的页脚，包含了与页面、文章或是内容有关的信息，比如说文章的作者或者日期。作为页面的页脚时，一般包含了版权、相关文件和链接。它和header标签使用基本一样，可以在一个页面中多次使用，如果在一个区段的后面加入footer,那么它就相当于该区段的页脚了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer&gt;</span><br><span class="line">   &lt;span&gt;copyRight@珠峰培训&lt;/span&gt;</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>7.hgroup<br>hgroup标签是对网页或区段section的标题元素(h1~h6)进行组合。例如,在一区段中你有连续的h系列的标签元素，则可以用hgroup将他们括起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;hgroup&gt;</span><br><span class="line">    &lt;h1&gt;主标题&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;副标题&lt;/h2&gt;</span><br><span class="line">&lt;/hgroup&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>8.figure<br>用作文档中插图的图像，带有一个标题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;figure&gt;</span><br><span class="line">      &lt;figcaption&gt;标题&lt;/figcaption&gt;</span><br><span class="line">      &lt;img src=&quot;img.jpg&quot; alt=&quot;figure标签&quot; title=&quot;figure标签&quot; /&gt;</span><br><span class="line"> &lt;/figure&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>9.figcaption<br>标签定义figure元素的标题(caption)。”figcaption”元素应该被置于”figure”元素的第一个或最后一个子元素的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;figure&gt;</span><br><span class="line">      &lt;img src=&quot;img.jpg&quot; alt=&quot;figure标签&quot; title=&quot;figure标签&quot; /&gt;</span><br><span class="line">      &lt;figcaption&gt;标题&lt;/figcaption&gt;</span><br><span class="line"> &lt;/figure&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>10.datalist<br>datalist标签定义选型列表。请与input元素配合使用该元素，来定义input可能的值。datalist及其选项不会被显示出来，它仅仅是合法的输入值列表。请使用input元素的list属性来 绑定datalist。所有主流浏览器都支持此标签，除了Internet Explorer和Safari。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;myCar&quot; list=&quot;cars&quot; /&gt;</span><br><span class="line">&lt;datalist id=&quot;cars&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;BMW&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;Ford&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;Volvo&quot;&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>11.audio<br>定义声音，比如音乐或其它音频流：其相关的属性<br>autoplay 如果出现该属性，则音频在就绪后马上播放;<br>controls 如果出现该属性，则向用户显示控件，比如播放按钮;<br>loop 如果出现该属性，则每当音频结束时重新开始播放；<br>muted 规定视频输出应该被静音；<br>preload 如果出现该属性，则音频在页面加载时进行加载，并预备播放,如果出现”autoplay”则忽略该属性；<br>src 要播放的音频的url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;audio id=&quot;audio&quot; preload=&quot;auto&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot; src=&quot;http://song4u.u.qiniudn.com/blog/audio/gt.mp3&quot;&gt;</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>12.video<br>定义视频，比如电影片段或其它视频流：其相关的属性<br>autoplay 如果出现该属性，则视频在就绪后马上播放;<br>controls 如果出现该属性，则向用户显示控件，比如播放按钮;<br>height 设置视频播放器的高度;<br>loop 如果出现该属性，则当媒介文件完成播放后再次开始播放；<br>preload 如果出现该属性，则视频在页面加载时进行加载，并预备播放,如果出现”autoplay”则忽略该属性；<br>src 要播放的音频的url；<br>width 设置视频播放器的宽度；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt;</span><br><span class="line">    &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;</span><br><span class="line"></span><br><span class="line">    您的浏览器不支持 video 标签。</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>13.canvas<br>canvas标签定义图形，比如图表和其他图像，canvas标签只是图形容器，您必须使用脚本来绘制图形;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var canvas=document.getElementById(&apos;myCanvas&apos;);</span><br><span class="line">var ctx=canvas.getContext(&apos;2d&apos;);</span><br><span class="line">ctx.fillStyle=&apos;#FF0000&apos;;</span><br><span class="line">ctx.fillRect(0,0,80,100);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>总结：<br>1、新增加一些构建页面语义化的结构标签 ，对原有 标签进行了修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header、nav、section、footer、article、aside、figure、figcaption、hgroup…</span><br><span class="line">(在IE6~8浏览器中不识别这些新增加的标签,导致布局结构混乱)在页面中引入</span><br></pre></td></tr></table></figure></p>
<p>&lt;!–[if lt IE 9]&gt;</p>
<p>&lt;![endif]–&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2、给我们的INPUT表单元素增加了很多新的类型(不兼容)</span><br><span class="line">```javascript</span><br><span class="line">原有:text、password、radio、checkbox、button、submit、reset、file…</span><br><span class="line">新增:search、url、email、tel、number、date、time、color、range…</span><br><span class="line">作用:</span><br><span class="line">1)根据TYPE的类型不一样,会调取出最符合用户输入的物理键盘;</span><br><span class="line">2)传统的表单验证:当某个行为触发的时候,我们获取用户输入的内容和自己编写的正则进行验证从而判断用户输入的是否符合规则;</span><br><span class="line">3) HTML5中提供了CSS3/JS的新验证方式,不需要自己写正则,浏览器自己就已经实现了验证,我们只需要控制成功/不成功的样式或者其他操作即可</span><br></pre></td></tr></table></figure></p>
<p>3、新增加了音视频处理AUDIO、VIDEO</p>
<p>4、新增加CANVAS绘图<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.hcharts.cn/(Highcharts)</span></span><br><span class="line">http:<span class="comment">//echarts.baidu.com/(echarts)</span></span><br><span class="line">D3.js</span><br></pre></td></tr></table></figure></p>
<p>5、新增加一些新的有助于开发的API:<br>本地存储localStorage/sessionStorge、<br>地理位置navigator.geolocation.getCurrentPosition、调取手机内部的GPS定位系统获取当前手机所在地的经纬度以及精准度<br>还提供了一些API，让我们可以通过浏览器调取手机内部的软件或者硬件（但是性能都不咋高，而且兼容性不是特别好）<br>websocket：socket.io、客户端和服务端新的传输方式（及时通讯IM系统基本上都是基于它完成的）<br>webworks…离线缓存</p>
<h4 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h4><p>ID<br>target</p>
<blockquote>
<p>A  .B{}   后代<br>A.B{}    子代<br>A&gt;B{}   具备A也具备B<br>A+B{}   下一个弟弟<br>A~B{}   兄弟<br><code>:nth-chld</code>某个元素下任意类型的子元素<br><code>:nth-of-type</code>某个元素下的同一类型中的第几个子元素<br><code>否定选择器</code><br><code>:not()</code><br><code>属性选择器</code><br>E[attr=val]<br>E[attr|=val]只能等于var或只能以val-开头<br>E[attr*=val]包含val字符串<br>E[attr~=val]属性值有多个，其中有一个时val<br>E[attr^=val]以val开头<br>E[attr$=val]以val结尾<br><code>目标伪类选择器</code><br><code>:target</code>用来匹配url指向的目标元素<br>存在url指向该匹配元素时样式效果才会生效<br>伪元素<br>:first-line匹配第一行文本<br>;first-letter匹配第一首字符<br>:before和after DOM元素前后插入额外的内容<br><code>圆角</code><br><code>border-radius</code>:左上 右上 右下 左下；<br><code>渐变</code><br><code>linear-gradient</code>([&lt;起点&gt;||&lt;角度&gt;,]?&lt;点&gt;,&lt;点&gt;…)<br>只能用在背景上<br>颜色是沿着一条直线轴变化<br>参数<br>-起点：从什么方向开始渐变》left、top、left top<br>-角度：从什么角度开始渐变》xxx deg的形式<br>-点：渐变点的颜色和位置》red50%,位置可选<br>重复现行渐变</p>
</blockquote>
<p><code>径向渐变</code><br><code>radial-gradient</code>([[<shape>||<size>][at <position>]?,|at<position>,]?<color-stop>[,<color-stop>]+);<br>从“一个点”向多方向颜色渐变<br>shape形状：ellipse、circle或设置水平半径，垂直半径<br>size：渐变的大小，即渐变到哪里停止，有如关键词：<br>closest-side：最近边；farthest-side:最远边；<br>closest-corner:最近角；farthest-corner：最远角（默认值）<br>position;关键词|数值|变化<br>重复的径向渐变</color-stop></color-stop></position></position></size></shape></p>
<hr>
<p><code>背景</code><br>background -color/-image/-position/-repeat/-attachment<br><code>background-origin</code><br>padding-box从padding区域显示<br>border-box从border区域显示<br>contert-box从content区域显示<br><code>background-clip</code><br>padding-box从padding区域向外裁剪<br>border-box从border区域往外裁剪<br>content-box从content区域往外裁剪<br><code>text文本裁剪</code><br><code>background-size</code><br>100px 100px:宽高具体值<br>100% 100%宽高百分比<br>cover以合适的比例图片进行缩放不会变形，用来铺满整个容器<br>contain原始比例收缩，显示完整但不一定铺满（一边碰到容器的边缘，则停止覆盖，导致部分区域是没有背景图的）<br>cover按原始比例收缩，可能显示不完整但铺满整个容器<br><code>background-attachment</code><br>背景图片是滚动的还是固定的fixed(固定的)默认是滚动的<br><code>box-shadow</code>:h水平方向偏移，v垂直方向偏移，blur模糊半径，spread扩展半径，color颜色，inset奖赏这个表示内阴影默认是外阴影。<br><code>text-shadow</code>:x y blur color<br>x轴偏移 y轴偏移 模糊度 颜色<br>多层阴影制作的文字立体效果设置多种颜色中间以逗号隔开<br><code>text-stroke</code>：2px blue<br>通过设定1px的透明边框，可以让文字变得平滑<br>颜色设定透明能创建镂空字体<br>mask-image遮罩<br>mask-position<br>mask-repeat<br>transform2D变换<br>box-sizing:border-box/padding-box/content-box(默认值)改变的就是我们在css中设置的width、height到底代表啥，border-box让其代表整个盒子的宽高当我们去修改padding或者border盒子大小不变只会让内容缩放<br>columns:多列布局<br>flex：弹性盒子模型，布局<br>perspective：视距 实现3D必用属性<br>@media：媒体查询 实现响应式布局的一种方案<br>@font-face：导入字体图标<br>transition<br>animation</p>
<hr>
<h3 id="CSS样式表"><a href="#CSS样式表" class="headerlink" title="CSS样式表"></a>CSS样式表</h3><table>
<thead>
<tr>
<th>元素</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>style</td>
<td>写样式</td>
</tr>
<tr>
<td>link</td>
<td>引入标签</td>
</tr>
<tr>
<td>list-style：none</td>
<td>去除ul，ol，dl默认样式</td>
</tr>
<tr>
<td>text-decoration: none;</td>
<td>去除a的下划线</td>
</tr>
<tr>
<td>font-weight: normal;</td>
<td>去除字体加粗，斜体</td>
</tr>
<tr>
<td>color: #ccc;</td>
<td>字体颜色</td>
</tr>
<tr>
<td>background-color:#faa770;</td>
<td>背景颜色</td>
</tr>
<tr>
<td>width: 100px;</td>
<td>盒子宽度</td>
</tr>
<tr>
<td>height :100px;</td>
<td>盒子高度</td>
</tr>
<tr>
<td>border-radius: 20px;</td>
<td>盒子圆角</td>
</tr>
<tr>
<td>line-height:100px;</td>
<td>文本行高</td>
</tr>
<tr>
<td>font-size : 16px ;</td>
<td>字体大小</td>
</tr>
<tr>
<td>font-weight: bold;</td>
<td>字体加粗</td>
</tr>
<tr>
<td>font-style: italic;</td>
<td>字体倾斜</td>
</tr>
<tr>
<td>letter-spacing: 10px;</td>
<td>字体间距</td>
</tr>
<tr>
<td>text-indent: 2em;</td>
<td>段落首行缩进</td>
</tr>
<tr>
<td>cursor:pointer</td>
<td>鼠标经过加小手</td>
</tr>
<tr>
<td>z-index:1;</td>
<td>改变重叠盒子层级关系</td>
</tr>
<tr>
<td>border-top:1px solid red;</td>
<td>上边框</td>
</tr>
<tr>
<td>border-right:1px solid red;</td>
<td>右边框</td>
</tr>
<tr>
<td>border-bottom:1px solid red;</td>
<td>下边框</td>
</tr>
<tr>
<td>border-left:1px solid red;</td>
<td>左边框</td>
</tr>
<tr>
<td>border-width:10px;</td>
<td>边框的宽度</td>
</tr>
<tr>
<td>border-color:red;</td>
<td>边框的颜色</td>
</tr>
<tr>
<td>border-style:solid(实线);dashed（虚线）；</td>
<td>边框的样式</td>
</tr>
<tr>
<td>border:10px solid #fff;</td>
<td>边框宽度 样式 颜色缩写</td>
</tr>
<tr>
<td>padding:1px 2px 3px 4px;</td>
<td>盒子内边距 上 右  下 左</td>
</tr>
<tr>
<td>margin:1px 2px 3px 4px;</td>
<td>盒子外边距 上 右  下 左</td>
</tr>
<tr>
<td>position: relative;</td>
<td>相对定位</td>
</tr>
<tr>
<td>position：absolute；</td>
<td>绝对定位</td>
</tr>
<tr>
<td>position: fixed;</td>
<td>固定定位</td>
</tr>
<tr>
<td>float：left</td>
<td>左浮动</td>
</tr>
<tr>
<td>float：right</td>
<td>右浮动</td>
</tr>
<tr>
<td>display：block</td>
<td>转为块元素</td>
</tr>
<tr>
<td>display：inline</td>
<td>转为行内元素</td>
</tr>
<tr>
<td>display:inline-block</td>
<td>转为行内块元素</td>
</tr>
<tr>
<td>display：none</td>
<td>让元素隐藏</td>
</tr>
<tr>
<td>overflow: hidden;</td>
<td>溢出盒子高度隐藏</td>
</tr>
<tr>
<td>overflow: scroll;</td>
<td>不管内容是否超出，都会出现滚动条</td>
</tr>
<tr>
<td>overflow: auto;</td>
<td>系统判断超出则出现滚动条不超出则不出现</td>
</tr>
<tr>
<td>white-space: nowrap;</td>
<td>让文本强制换行</td>
</tr>
<tr>
<td>text-overflow:ellipsis;</td>
<td>让超出的文本以三个小点的方式出现</td>
</tr>
<tr>
<td>hover</td>
<td>鼠标经过时的状态</td>
</tr>
<tr>
<td>active</td>
<td>鼠标点击时的状态</td>
</tr>
<tr>
<td>visited</td>
<td>鼠标点击后的状态</td>
</tr>
<tr>
<td>text-align:  right ; left ；</td>
<td>文字水平居右，左</td>
</tr>
<tr>
<td>text-align: center;</td>
<td>文字水平居中</td>
</tr>
<tr>
<td>line-height: 50px;</td>
<td>文本垂直居中</td>
</tr>
<tr>
<td>vertical-align：top</td>
<td>平级元素顶部对齐</td>
</tr>
<tr>
<td>vertical-align：middle；</td>
<td>平级元素中部对齐</td>
</tr>
<tr>
<td>vertical-align：bottom;</td>
<td>平级元素底部对齐</td>
</tr>
<tr>
<td>margin:0 auto;</td>
<td>盒子，版心，位置居中</td>
</tr>
<tr>
<td>box-shadow: .02rem .02rem .02rem .02rem rgba(178,178,178,.75),-.02rem .02rem .02rem .02rem rgba(178,178,178,.75);</td>
<td>盒子阴影</td>
</tr>
<tr>
<td>text-shadow： .02rem .02rem .02rem .02rem rgba(178,178,178,.75);</td>
<td>文字阴影</td>
</tr>
<tr>
<td>link rel=”icon” href=”img/favicon.ico” type=”image/x-icon</td>
<td>引入图标(页面标题的前面–页卡)</td>
</tr>
<tr>
<td>给body或者父级元素设置font-size:0;</td>
<td>清除间隙问题</td>
</tr>
<tr>
<td>opacity:0.5;</td>
<td>设置透明度</td>
</tr>
<tr>
<td>filter:alpha(opacity=50)</td>
<td>设置透明度 兼容ie低版本8以下浏览器</td>
</tr>
<tr>
<td>background: url(“图片路径”) no-repeat（不平铺）;</td>
<td>背景图片</td>
</tr>
<tr>
<td>background-position: center center；</td>
<td>改变背景图片的位置、水平垂直居中</td>
</tr>
<tr>
<td>background-size:100% 100%;</td>
<td>改变背景图片的大小</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>background: red url(“pic_02.png”) no-repeat center center;—–这种写法格式是在项目中最常用</strong><br> <strong>background:背景颜色  背景图片的路径  背景图片是否平铺   改变背景图片的位置</strong>&gt;</p>
</blockquote>
<blockquote>
<p><strong>实现隔行变色</strong>&lt;<br>-<strong>单独获取容器中的某一个子元素</strong> ——|||||||||||——  <strong>EVEN : 偶数 \ ODD : 奇数</strong>-<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* nth-child(n):当前容器所有子元素中的第N个</span><br><span class="line">    *    .box li:nth-child(1)：BOX容器所有子元素中的第一个并且标签名是LI的</span><br><span class="line">* nth-of-type(n):先给当前容器按照某一个标签名进行分组,获取分组中的第N个</span><br><span class="line">    *    .box li:nth-of-type(1)：先获取BOX中所有的LI，在获取LI中的第一个</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>实心小三角</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">            border-color:  transparent（边框透明）  transparent   transparent   #0d0d0d ;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            border-width: <span class="number">40</span>px;  &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>色值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>英文单词</td>
<td>red,yellow,green,blue—工作中不用，在低版本浏览器下不兼容</td>
</tr>
<tr>
<td>16进制</td>
<td>#ff0000 #666767   简写：#f00  #fff(白色)/#000(黑色) —常用</td>
</tr>
<tr>
<td>rgb</td>
<td>red红,green绿,blue蓝</td>
</tr>
<tr>
<td>rgba</td>
<td>red红,green绿,blue蓝,a透明度(值：0-1)—常用</td>
</tr>
<tr>
<td>颜色值在工作中最常用的是</td>
<td>16进制、rgba，</td>
</tr>
<tr>
<td>白色rgb(255,255,255)</td>
</tr>
<tr>
<td>黑色rgb(0,0,0)</td>
</tr>
</tbody>
</table>
<blockquote>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>header</td>
<td>头部</td>
</tr>
<tr>
<td>footer</td>
<td>尾部</td>
</tr>
<tr>
<td>nav</td>
<td>导航</td>
</tr>
<tr>
<td>section</td>
<td>区分大模块</td>
</tr>
<tr>
<td>aside</td>
<td>侧边栏</td>
</tr>
<tr>
<td>article</td>
<td>文章</td>
</tr>
<tr>
<td>figure</td>
<td>配图</td>
</tr>
<tr>
<td>figcaption</td>
<td>配图说明</td>
</tr>
<tr>
<td>video</td>
<td>视频</td>
</tr>
<tr>
<td>audio</td>
<td>音频</td>
<td>&lt;</td>
</tr>
<tr>
<td>main</td>
<td>主体</td>
</tr>
<tr>
<td>video 视频</td>
<td>audio音频</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>src=”” 视频路径</td>
<td>autoplay 自动播放</td>
</tr>
<tr>
<td>controls 是否显示控件</td>
<td>loop 循环播放</td>
<td>&lt;</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>表单</td>
<td>功能</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>input type=”number”</td>
<td>数字</td>
</tr>
<tr>
<td>input type=”email”</td>
<td>邮箱</td>
</tr>
<tr>
<td>input type=”file”</td>
<td>上传文件</td>
</tr>
<tr>
<td>input type=”search”</td>
<td>搜索框</td>
<td>&lt;</td>
</tr>
</tbody>
</table>
</blockquote>
<table>
<thead>
<tr>
<th>REM布局</th>
<th>最终版</th>
</tr>
</thead>
<tbody>
<tr>
<td>参照iphone5/5s</td>
<td>设计稿尺寸640 分辨率320*2  dpr:2.0</td>
</tr>
<tr>
<td>参照iphone5/5s</td>
<td>分辨率320*2 html{ font-size:50px;}</td>
</tr>
<tr>
<td>参照iphone6/6s</td>
<td>分辨375*2 html{font-size:58.59375px;}</td>
</tr>
<tr>
<td>参照iphone6Plus</td>
<td>分辨率：414*3 html{font-size:64.6875px;}</td>
</tr>
<tr>
<td>分辨率：640</td>
<td>html{font-size:100px;}</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>照iphone6/6s</td>
<td>设计稿尺寸750 分辨率375*2 dpr:2.0</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>参照物iphone6/6s</td>
<td>分辨率：375*2  html{font-size:50px;}</td>
</tr>
<tr>
<td>iphone5/5s</td>
<td>分辨率：320*2 dpr:2.0 html{font-size:42.66px;}</td>
</tr>
<tr>
<td>iphone6Plus</td>
<td>分辨率：414*3  dpr:3.0 html{font-size:55.2px;}</td>
</tr>
<tr>
<td></td>
<td>分辨率：640    html{font-size:85.33px;}</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
</tbody>
</table>
<p><strong>transform—2D转换</strong><br>| 属性值 | 描述 |<br>|–|–|<br>|translate() 平移 |元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数|<br>|rotate() 旋转 |    元素顺时针旋转给定的角度（角度单位：deg）。允许负值，元素将逆时针旋转|<br>|scale() 放大或缩小|    元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数|<br>|skew() 倾斜、翻转|    元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数|</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/22/JQuery解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/JQuery解读/" itemprop="url">JQuery解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-22T01:09:00+08:00">
                2018-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><blockquote>
<ul>
<li>“类库”：提供一些真实项目中的常用方法；任何项目都可以把类库导入进来调取里面的方法实现自己需要的业务逻辑。<br>zepto:移动端的类库</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>插件;具备一定的业务功能，例如我们可以封装轮播图插件、选项卡插件、模态框插件等（插件规定了当前这个功能的样式结构把实现功能的js进行封装，以后想实现这个功能直接导入插件即可）swiper/iscroll/jquery-dialog/jquery-drag/jquery-datepicker/ECharts…</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>UI组件:把结构css/js全都封装好了想要实现一个功能直接导入进来即可bootstrap…</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>框架：具备一定的编程思想要求我们按照框架的思想开发，一般框架中提供了常用的类库方法提供了强大的功能插件有的也提供了强大的UI组件…React (React native)/VUE/Angular/Backbone/Sea.js/Require.js…</li>
</ul>
</blockquote>
<p>jQuery是基于js封装的一个类库提供了很多方法而且这些方法是兼容所有浏览器的<br>jQ版本：v1（常用 1.8.3/1.9.3/1.11.3）v2（移动端,但不如zepto) v3()<br>jq选择器：基于各种选择器创建一个jq实例（jq对象）：$()<br>两个参数：<br><code>selector</code>：选择器的类型一般都是字符串但是支持函数或者元素对象。<br><code>context</code>：基于选择器获取元素时候指定的上下文默认是document。<br>jq对象：一个类数组结构（jq实例）这个类数组集合当中包含了获取到的元素。</p>
<h3 id="JQ的核心原理解读（分析原代码）"><a href="#JQ的核心原理解读（分析原代码）" class="headerlink" title="JQ的核心原理解读（分析原代码）"></a>JQ的核心原理解读（分析原代码）</h3><blockquote>
<p>JQ是一个常用方法类库（常用的DOM库），提供了很多真实项目开发中需要使用的属性和方法（这些方法JQ已经帮我们完善了浏览器兼容处理以及一些细节的优化）</p>
</blockquote>
<p><code>jQuery本身是一个类
JQ是基于构造函数模式构建的类库</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jQuery=<span class="function"><span class="keyword">function</span>(<span class="params">selector,context</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jQuery.fn=jQuery.prototype=&#123;</span><br><span class="line">	jquery:version,</span><br><span class="line">	<span class="keyword">constructor</span>:jQuery,</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">init=jQuery.fn.init=function(selector, context)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> selector==<span class="string">"string"</span>)&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(selector.nodeType)&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(jQuery.isFunction(selector))&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> jQuery.makeArray(selector,<span class="keyword">this</span> );<span class="comment">//=&gt;返回的是一个类数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init.prototype=jQuery.fn;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.jQuery=<span class="built_in">window</span>.$=jQuery;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当我们在JS中执行：<br>\$()<br>jQuery()</p>
<p>都是在创建一个JQ类的实例（$===jQuery），这些实例都是一个类数组（我们把这个类数组称之为JQ对象），JQ的实例可以使用JQ原型上提供的公有的属性和方法</p>
<p>项目中我们把\$()称之为JQ的选择器，因为执行这个方法可以传递一个selector参数进去，通过selector我们可以获取到需要操作的DOM元素集合（JQ类数组集合）；传递的第二个参数context它是当前获取元素的上下文（不传递默认是document，如果传递，我们传递一个JS元素对象即可）</p>
<p>但是把它叫做JQ选择器有点笼统，因为传递的selector支持三种格式：<br>传递的是个字符串，就是我们所谓的选择器，能够通过选择器获取到元素<br>传递的是个元素对象，它的意思是把JS原生对象转换为JQ对象<br>传递的是个函数，它代表等DOM结构加载完成在执行对应的JS代码（类似于window.onload）</p>
<p>…</p>
</blockquote>
<p><code>JQ的选择器</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$===jQuery  <span class="comment">//=&gt;true</span></span><br><span class="line">$()===jQuery() <span class="comment">//=&gt;false 不同实例</span></span><br><span class="line">$() <span class="keyword">instanceof</span> jQuery <span class="comment">//=&gt;true</span></span><br><span class="line"><span class="keyword">var</span> $example=$(); <span class="comment">//=&gt;我们用JQ选择器获取的值，一般都是用以$开头的变量名来存储（以后看见变量名是以$开头的，我们就知道是JQ获取的实例[JQ对象]）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$example</span></span><br><span class="line"><span class="comment">[xxx:xxx  私有的属性]</span></span><br><span class="line"><span class="comment">0:某一个元素对象</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">length:类数组的长度</span></span><br><span class="line"><span class="comment">context:document</span></span><br><span class="line"><span class="comment">selector:'传递的选择器内容'</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">__protot__：jQuery.prototype</span></span><br><span class="line"><span class="comment">   [xxx:xxx 公有的属性和方法]</span></span><br><span class="line"><span class="comment">   add</span></span><br><span class="line"><span class="comment">   addClass</span></span><br><span class="line"><span class="comment">   ...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> __proto__:Object.prototype</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>第一个参数[selector]传递的是一个字符串，就是通过选择器获取需要的元素集合（获取的结果怎么着都是类数组集合：获取多个元素也就是索引多点，获取一个元素也就是只有索引0，一个都没获取到就是一个空的类数组集合[而不是null]）</p>
<p>一般CSS或者CSS3中支持的选择器，JQ都支持<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;基本选择器</span></span><br><span class="line">$(<span class="string">'#xxx'</span>)</span><br><span class="line">$(<span class="string">'.xxx'</span>)</span><br><span class="line">$(<span class="string">'xxx'</span>)</span><br><span class="line">$(<span class="string">'*'</span>)</span><br><span class="line">$(<span class="string">'.xxx,#xxx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;后代选择器</span></span><br><span class="line">$(<span class="string">'.box a'</span>)</span><br><span class="line">$(<span class="string">'.box&gt;a'</span>)</span><br><span class="line"><span class="comment">//$('.box~a')</span></span><br><span class="line"><span class="comment">//$('.box+a') 不常用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;伪类选择器</span></span><br><span class="line">$(<span class="string">'.box:contains(xxx)'</span>) 包含某某某内容的</span><br><span class="line">$(<span class="string">'a:first'</span>)</span><br><span class="line">$(<span class="string">'a:last'</span>)</span><br><span class="line">$(<span class="string">'a:eq(1)'</span>) 索引为<span class="number">1</span>的</span><br><span class="line">$(<span class="string">'a:gt(1)'</span>) 索引大于<span class="number">1</span>的</span><br><span class="line">$(<span class="string">'a:lt(10)'</span>) 索引小于<span class="number">10</span>的</span><br><span class="line">$(<span class="string">'a:not()'</span>) 不包含什么的</span><br><span class="line">$(<span class="string">'a:not(:gt(5))'</span>) 获取所有的a，但是不包含索引大于<span class="number">5</span>的（前六个）</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;属性选择器</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="JQ对象和原生JS对象转换"><a href="#JQ对象和原生JS对象转换" class="headerlink" title="JQ对象和原生JS对象转换"></a><code>JQ对象和原生JS对象转换</code></h4><blockquote>
<p>JQ对象：通过$()获取的JQ实例(类数组)<br>原生JS对象：通过ES中提供的属性或者方法获取的JS元素对象(nodeType===1)</p>
<p>把JQ对象转换为原生JS对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oBox=<span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);<span class="comment">//=&gt;原生JS对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//oBox.addClass();//=&gt;报错：oBox不是JQ对象，不能使用JQ原型上的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $box=$(oBox); <span class="comment">//=&gt;把原生JS对象转换为JQ对象</span></span><br><span class="line">$box.addClass(<span class="string">'bg'</span>);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>把JQ对象转换为原生JS对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $body=$(<span class="string">'body'</span>);</span><br><span class="line"><span class="comment">//$body.className //=&gt;undefined，因为className是JS原生内置的属性，JQ对象不能直接的用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//$body[索引]：在集合中获取指定索引的内容（获取的内容就是原生JS对象）</span></span><br><span class="line"><span class="comment">//$body.get(索引)：等价于 $body[索引]，获取指定索引位置的元素（原生JS对象）</span></span><br><span class="line"><span class="comment">//$body.eq(索引)：获取指定索引位置的元素对象（获取的结果还是一个新的JQ对象）</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="selector是一个方法"><a href="#selector是一个方法" class="headerlink" title="selector是一个方法"></a><code>selector是一个方法</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//=&gt;当页面中的DOM结构加载完成，就会执行回调函数中的JS代码</span></span><br><span class="line">	<span class="comment">//=&gt;类似于window.onload：等到页面中的DOM结构以及资源文件都加载完成才会执行对应的JS代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//=&gt;这种写法和上面的写法一模一样</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>和window.onload不太一样<br>1、$(function(){}) 可一在同一个页面中使用多次，多次都生效（所以在使用JQ完成代码的时候，我们一般都会把代码放在回调函数中：首先不仅是等到结构加载完在执行，而且还形成了一个闭包）<br>原理：利用了DOM二级事件绑定(可以执行多次)，监听的是DOMContentLoaded事件(DOM结构加载完成就会触发执行)</p>
<p>2、window.onload本身就是资源都加载完成才会执行，使用的是DOM零级事件绑定，在同一个页面中只能使用一次<br>window.onload=function()…<br>window.onload=function()…<br>只能留最后一个，最后一次赋值替换了原有赋值</p>
</blockquote>
<h3 id="JQ即是一个类也是一个对象"><a href="#JQ即是一个类也是一个对象" class="headerlink" title="JQ即是一个类也是一个对象"></a>JQ即是一个类也是一个对象</h3><blockquote>
<p>jQuery.prototype上设置了很多的属性和方法，这些是供JQ实例（DOM集合或者DOM元素）使用的属性和方法<br>addClass<br>css<br>removeClass<br>attr<br>…</p>
<p>jQuery也是一个普通的对象，在对象上也有一些自己的属性和方法（和实例没有任何的关系）,这些都是工具类的方法<br>ajax<br>isFunction<br>unique<br>…</p>
</blockquote>
<h4 id="jQuery-prototype"><a href="#jQuery-prototype" class="headerlink" title="jQuery.prototype"></a><code>jQuery.prototype</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).index()：获取当前元素的索引（是在自己兄弟元素中的索引，它有几个哥哥，索引就是几）</span><br><span class="line"></span><br><span class="line">$(<span class="string">'body'</span>).data(key,value)</span><br><span class="line">只传递key是获取</span><br><span class="line">如果传递了value是设置</span><br><span class="line">我们通过这个方法可以获取到在HTML结构上设置的data-xxx的自定义属性值</span><br><span class="line"><span class="comment">//&lt;body data-index='12'&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="comment">//$('body').data('index') =&gt;12</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'#box'</span>).attr()：设置或者批量设置或者获取当前元素的自定义属性(内置属性也可以)  removeAttr</span><br><span class="line">$(<span class="string">'#box'</span>).prop()：和attr一样也是操作元素属性的，但是prop一般都操作表单元素的内置或者自定义属性 removeProp</span><br><span class="line"></span><br><span class="line">addClass：增加样式类</span><br><span class="line">removeClass：移除样式类</span><br><span class="line">toggleClass：当前样式类有就是移除，没有就是增加</span><br><span class="line">hasClass：验证是否存在某个样式类名</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#box'</span>).html([val])：不传val就是获取内容，传递val就是设置内容，等价于原生的innerHTML</span><br><span class="line">$(<span class="string">'input'</span>).val([val])：表单元素value值的操作(设置或者获取)</span><br><span class="line"></span><br><span class="line">css：设置或者批量设置或者获取元素的样式（获取的结果没有去单位）</span><br><span class="line"></span><br><span class="line">offset()：获取距离BODY的偏移</span><br><span class="line">position()：获取距离父级参照物的偏移</span><br><span class="line">scrollTop/scrollLeft([val])：获取或者设置当前元素卷去的高度或者宽度</span><br><span class="line">height/width([val])</span><br><span class="line">innerWidth/innerHeight()：等价于clientWidth/clientHeight</span><br><span class="line">outerWidth/outerHeight()：等价于offsetWidth/offsetHeight</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#box'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>...)：<span class="title">JQ</span>中的事件绑定</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">$</span>(<span class="params"><span class="string">'#box'</span></span>).<span class="title">remove</span>(<span class="params"></span>)：把当前盒子在容器中移除</span></span><br><span class="line"><span class="function"><span class="title">$</span>(<span class="params"><span class="string">'#box'</span></span>).<span class="title">clone</span>(<span class="params">true</span>)：把当前盒子深度克隆一份</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">filter</span></span></span><br><span class="line"><span class="function"><span class="title">children</span></span></span><br><span class="line"><span class="function"><span class="title">find</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>
<p><code>写在对象上的方法</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j=$.noConflict()：如果当前项目中引入了两个类库，都是使用$操作的，为了防止$使用权的冲突，JQ做了一个处理，可以让我们转让$的使用权；此处返回的值j就是代表原始$的变量，以后可以使用j()执行（使用jQuery()执行也可以）</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j=$.noConflict(<span class="literal">true</span>)：深度转让，把jQuery和$的使用权都转让了，此时只能使用j()执行了</span><br><span class="line"></span><br><span class="line">$.ajax()：帮助我们发送ajax请求</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h4 id="筛选方法"><a href="#筛选方法" class="headerlink" title="筛选方法"></a><code>筛选方法</code></h4><blockquote>
<p>filter：同级过滤<br>children：子集过滤<br>find：后代过滤<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $links=$(<span class="string">'a'</span>);</span><br><span class="line">$links.filter(<span class="string">'.bg'</span>); <span class="comment">//=&gt;首先获取所有的A，在所有的A中把具备样式类为bg的获取到（二次筛选）</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'#box'</span>).children(<span class="string">'a'</span>); <span class="comment">//=&gt;首先获取#box所有的子元素，在所有子元素中筛选出标签名为a的元素集合 &lt;=&gt; $('#box&gt;a')</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'#box'</span>).find(<span class="string">'.bg'</span>); <span class="comment">//=&gt;首先获取#box后代中所有的元素，在所有的元素中筛选出样式类名中具备bg的元素集合 &lt;=&gt; $('#box .bg')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//prev：获取上一个哥哥  $('#box').prev('a')</span></span><br><span class="line"><span class="comment">//prevAll：所有的哥哥</span></span><br><span class="line"><span class="comment">//next：下一个弟弟</span></span><br><span class="line"><span class="comment">//nextAll：所有的弟弟</span></span><br><span class="line"><span class="comment">//siblings：所有的兄弟</span></span><br><span class="line"><span class="comment">//parent：父亲元素</span></span><br><span class="line"><span class="comment">//parents：所有的祖先元素（一直到html为止）</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="each"><a href="#each" class="headerlink" title="each"></a><code>each</code></h4><blockquote>
<p>JQ中的each有三种<br>1、写在原型上的each：遍历JQ对象中的每一项<br>2、写在对象上的each：工具方法，可以用来遍历数组、类数组、对象等<br>3、内置的each其实也是调用原型上的each处理的，只不过JQ在处理的时候会内部自己调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;内置EACH</span></span><br><span class="line">$(<span class="string">'a'</span>).addClass(<span class="string">'select'</span>); <span class="comment">//=&gt;我们获取的A可能有很多个，执行一次addClass，相当于给每个获取的A都增加了一个叫做select的样式类（JQ中大部分方法在执行的时候，都会把获取的JQ集合中的每一项调用each进行遍历，把需要操作的任务对每一个遍历的元素进行操作）</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'a'</span>).css(<span class="string">'width'</span>); <span class="comment">//=&gt;获取的时候只返回第一个元素的样式（设置走内置EACH批量处理，获取只处理第一个）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;原型上的EACH</span></span><br><span class="line">$(<span class="string">'a'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,item</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//=&gt;传递参数的顺序和数组内置的forEach顺序相反：ary.forEach(function(item,index)&#123;...&#125;);</span></span><br><span class="line">    <span class="comment">//=&gt;获取的A有多少个，回调函数被触发执行多少次：index当前遍历这一项的索引 item是当前遍历这一项的内容</span></span><br><span class="line">    <span class="comment">//=&gt;this -&gt; item (原生JS对象) 方法中的this是当前遍历的这一项</span></span><br><span class="line">    <span class="comment">//=&gt;$(this) 也是当前遍历这一项，但是属于JQ对象</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;JQ对象上提供的工具方法：each</span></span><br><span class="line">$.each([数组/类数组], <span class="function"><span class="keyword">function</span>(<span class="params">index,item</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//=&gt;this:item</span></span><br><span class="line">&#125;);</span><br><span class="line">$.each([对象],<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//=&gt;this:value</span></span><br><span class="line">	<span class="comment">//=&gt;JQ也是采用for in循环用来遍历对象的，这样的话就存在可能把公有属性和方法遍历到的问题</span></span><br><span class="line">	<span class="keyword">if</span>([对象].hasOwnProperty(key))&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="extend"><a href="#extend" class="headerlink" title="extend"></a><code>extend</code></h4><blockquote>
<p>\$.extend()：把方法扩展到JQ对象上，这个操作一般是用来完善类库的<br>$.fn.extend()：把方法扩展到JQ的原型上，供JQ的实例（DOM集合）使用，这个操作一般是用来写JQ插件的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;扩展工具方法，用来完善类库</span></span><br><span class="line">$.extend(&#123;</span><br><span class="line">	aa:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">$.aa();</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;扩展到原型上供实例调用的</span></span><br><span class="line">$.fn.extend(&#123;</span><br><span class="line">	bb:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//=&gt;this:操作当前这个方法的JQ实例（JQ对像），此处不需要再$(this)转换为JQ对像</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'xxx'</span>).bb();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="animate"><a href="#animate" class="headerlink" title="animate"></a><code>animate</code></h4><blockquote>
<p>JQ中提供了元素运动的动画库<br>stop：结束当前元素正在运行的动画，继续执行下一个新动画（一般我们实现动画,stop方法基本上必然执行）<br>finish：和stop类似，finish需要让元素立即运动到上一个动画的目标位置，从目标位置执行下一个动画，而stop是从上一个动画停止的位置执行下一个动画</p>
<p>animate([target],[duration],[effect],[callBack])：<br>[target] 对象<br>[duration] MS<br>[effect]  linear、ease、ease-in、ease-out、ease-in-out<br>[callBack] 回调函数，动画结束做的事情</p>
<p>show(1000/‘fast’/‘slow’)<br>hide<br>toggle</p>
<p>fadeIn<br>fadeOut<br>fadeToggle</p>
<p>slideUp<br>slideDown<br>slideToggle<br>…</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/22/call、apply、bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/call、apply、bind/" itemprop="url">call、apply、bind</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-22T01:07:18+08:00">
                2018-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call  apply  bind"></a>call  apply  bind</h3><blockquote>
<p>都是天生自带的方法(Function.prototype)，所有的函数都可以调取这三个方法<br><code>三个方法都是改变THIS指向的</code></p>
</blockquote>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p><code>call</code></p>
<blockquote>
<p>fn.call(context,para1,…)<br>把fn方法执行，并且让fn方法中的this变为context,而para1…都是给fn传递的实参<br>1.非严格模式下如果参数不传或者第一个传递的是null、undefined，this指向window<br>2.严格模式下第一个参数是谁，this就指向谁（包括null、undefined）不传this是undefined</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;非严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">fn</span>:fn&#125;;</span><br><span class="line">fn();<span class="comment">//=&gt;this:window</span></span><br><span class="line">obj.fn();<span class="comment">//=&gt;this:obj</span></span><br><span class="line"><span class="keyword">var</span> opp=&#123;&#125;;</span><br><span class="line"><span class="comment">//opp.fn();//=&gt;报错:opp中没有fn这个属性</span></span><br><span class="line">fn.call(opp);<span class="comment">//=&gt;this:opp num1&amp;&amp;num2都是undefined</span></span><br><span class="line">fn.call(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//=&gt;this:1 num1=2 num2=undefined</span></span><br><span class="line">fn.call(opp,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//=&gt;this:opp num1=1 num2=2</span></span><br><span class="line"><span class="comment">//-&gt;CALL方法的几个特殊性</span></span><br><span class="line">fn.call();<span class="comment">//=&gt;this:window   num1&amp;&amp;num2都是undefined</span></span><br><span class="line">fn.call(<span class="literal">null</span>);<span class="comment">//=&gt;this:window</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>);<span class="comment">//=&gt;this:window</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;JS严格模式下</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">fn.call();<span class="comment">//=&gt;this:undefined</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>);<span class="comment">//=&gt;this:undefined</span></span><br><span class="line">fn.call(<span class="literal">null</span>);<span class="comment">//=&gt;this:null</span></span><br></pre></td></tr></table></figure>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><blockquote>
<p>apply的语法和call基本一致，作用原理也基本一致，唯一的区别：apply把传递给函数的实参以数组形式存放（但是也相当于在给函数一个个的传递实参值）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(<span class="literal">null</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">fn.apply(<span class="literal">null</span>,[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]); <span class="comment">//=&gt;传递给fn的时候也是一个个的传递进去的</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p><code>bind</code>预处理机制</p>
<blockquote>
<p>也是改变THIS的方法，它在IE6~8下不兼容；它和call(以及apply)改变this的原理不一样，区别于立即执行还是等待执行。<br>把所有参数传给点前面的方法，返回一个接受参数后的小函数，返回值是函数的定义<br>预处理机制：提前把所有的事情都弄好，最终函数执行需要手动运行</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fn.call(opp,<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//=&gt;把fn执行,让fn中的this变为opp,并且把10&amp;&amp;20分别传递给fn</span></span><br><span class="line"></span><br><span class="line">fn.bind(opp,<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//=&gt;预先让fn中的this指向opp,并且把10和20预先传递给fn,此时的fn没有被执行(只有当执行的时候this和实参才会起到应有的作用)</span></span><br><span class="line"><span class="comment">//=&gt;需求：点击box这个盒子的时候，需要执行fn，并且让fn中的this指向opp</span></span><br><span class="line">oBox.onclick=fn; <span class="comment">//=&gt;点击的时候执行了fn,但此时fn中的this是oBox</span></span><br><span class="line"></span><br><span class="line">oBox.onclick=fn.call(opp); <span class="comment">//=&gt;绑定事件的时候就已经把fn立即执行了(call本身就是立即执行函数),然后把fn执行的返回值绑定给事件</span></span><br><span class="line"></span><br><span class="line">oBox.onclick=fn.bind(opp);</span><br><span class="line"><span class="comment">//=&gt;fn.bind(opp)：fn调取Function.prototype上的bind方法，执行这个方法返回了一个匿名函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function()&#123;</span></span><br><span class="line"><span class="comment"> *     fn.call(opp);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">oBox.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//=&gt;this:oBox</span></span><br><span class="line">	fn.call(opp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;</span><br><span class="line"> fn1.call(fn2);<span class="comment">//=&gt;找到CALL-AA把它执行,CALL-AA中的THIS是FN1,第一个参数传递的是FN2  =&gt;在CALL-AA中执行的是FN1 =&gt;1</span></span><br><span class="line"></span><br><span class="line"> fn1.call.call(fn2);<span class="comment">//=&gt;找到CALL-AA让它执行,CALL-AA中的THIS是FN1.CALL,第一个参数是FN2  (把FN1.CALL中的THIS变为FN2，再让FN1.CALL执行  =&gt;先找到CALL-AA，把它执行，只不过此时它中的THIS是FN2 =&gt;让FN2中的THIS变为UNDEFINED，因为执行FN1.CALL的时候没有传递参数值，然后让FN2执行)  =&gt;2</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">Function</span>.prototype.call(fn1);<span class="comment">//=&gt;先找到CALL-AA把它执行，它中的THIS是Function.prototype =&gt;让F.P中的THIS变为FN1,然后让F.P执行,F.P是一个匿名函数也是一个空函数，执行没有任何的输出</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.call.call(fn1);<span class="comment">//=&gt;先找到CALL-AA把它执行，它中的THIS是F.P.CALL =&gt;把F.P.CALL中的THIS修改为FN1,让F.P.CALL执行  =&gt;F.P.CALL(CALL-AA)第二次把它执行(此时它里面的THIS已经是FN1) =&gt;这一次其实在CALL-AA中是让FN1执行 =&gt;1</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>查看函数原型上的方法：<br>call/apply/bind-&gt;改变调用主体的this关键字<br>call()第一个参数：用来改变<code>.</code>前面方法的this关键字，从第二个参数开始，以散列式的方式给<code>.</code>前面的方法传参.—散列式.<br>fn.apply()第一个参数：用来改变<code>.</code>前面方法的this关键字，第二个参数是用来给<code>.</code>前面的方法传参（把所有的参数放在数组里传给<code>.</code>前面的方法）—打包式.</p>
</blockquote>
<p>非严格模式下</p>
<blockquote>
<p>call/apply第一个参数不传，传null,传undefined-&gt;<code>.</code>前面方法里的this都是window<br>严格模式下-》规范<br>好处：<br>1.更加安全高效<br>2.提高编译器编译代码的速度<br>3.跟高版本浏览器接轨<br>第一个参数不传是undefined，其他传什么就是什么<br>fn1.call.call.call.call(fn2);<br>最后一个call作用<br>1.让点前面方法里的this关键字改成fn2-&gt;call方法里this-&gt;fn2<br>2.让点前面方法运行-&gt;function.prototype.call()-&gt;this()-&gt;fn2()</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/22/函数的三种角色/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/函数的三种角色/" itemprop="url">函数的三种角色</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-22T01:00:09+08:00">
                2018-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="函数的三种角色"><a href="#函数的三种角色" class="headerlink" title="函数的三种角色"></a>函数的三种角色</h3><blockquote>
<p><strong>第一种角色：普通函数</strong><br>堆栈内存释放、<br>作用域链、<br>…</p>
<p><strong>第二种角色：类</strong><br>实例<br>prototype原型<br>__proto__原型链<br>…<br><strong>第三种角色：普通对象</strong><br>键值对的增删改查<br>…<br> <code>对象</code>：<br>普通对象、数组、正则、math、json、arguments…<br><code>实例</code>是对象类型的（除了基础数据类型的字面量创建的值）<br><code>prototype</code>的值也是对象类型<br><code>函数</code>也是对象类型的。<br>阿里超经典面试题（有难度）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName();<span class="comment">//=&gt;2 把FOO作为对象,找其私有属性</span></span><br><span class="line">getName();<span class="comment">//=&gt;4 执行全局下的GET-NAME</span></span><br><span class="line">Foo().getName();<span class="comment">//=&gt;1 先把FOO作为普通函数执行,把执行的结果window调取GET-NAME在执行</span></span><br><span class="line"><span class="built_in">window</span>.getName();<span class="comment">//=&gt;1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName();<span class="comment">//=&gt;先获取Foo.getName的值(假设B),然后再new B()相当于创建B的实例 =&gt;2  (new Foo.getName;一样的)</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName();<span class="comment">//=&gt;new Foo()当做一个整体获取实例，把得到的实例在调取GET-NAME  =&gt;3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();</span><br><span class="line"><span class="comment">//=&gt;var f=new Foo()//=&gt;实例是this这是空的</span></span><br><span class="line"><span class="comment">//=&gt;new f.getName();  =&gt;new (f.getName)(); =&gt;3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obj.getX();//=&gt;先获取obj的getX的属性值，然后把获取的值执行</span></span><br></pre></td></tr></table></figure></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/22/类的封装：继承和多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/类的封装：继承和多态/" itemprop="url">类的继承：封装和多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-22T00:29:16+08:00">
                2018-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="类的继承：封装和多态"><a href="#类的继承：封装和多态" class="headerlink" title="类的继承：封装和多态"></a>类的继承：封装和多态</h3><p><code>[封装]</code>：把实现一个功能的js代码进行封装主要目的：低耦合高内聚<br><code>[多态]</code>：重载：方法名相同，参数的个数或者类型不同，此时名字相同的方法叫做方法的重载（后台语言的重载），js中不存在重载的<br>重写：子类重写父类的方法<br><code>[继承]</code>：子类继承父类的方法和属性</p>
<h4 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h4><h5 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h5><p><code>原型继承</code>:让子类原型指向父类的一个实例。<br>原型继承方式：<code>B.prototype=new A();</code><br>A的实例本身具备父类A的私有属性和公有方法，子类B的原型指向它，那么子类的B的实例就可以找到这些属性和方法了.<br>和传统后台语言的继承不一样，子类继承父类并不是把父类的属性方法克隆一份给子类的（这样处理子类和父类就没有直接关系了）js中的原型继承是让子类和父类建立原型链接方式，子类的实例调取父类原型上的方法都是基于原型链的查找机制完成的。存在问题是：子类可以重写父类原型上的方法（重写），子类和父类还有关系的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.prototype.\__proto__.getX=null;//把父类A的原型上的getX重写为null，A的其他实例会受到影响</span><br></pre></td></tr></table></figure>
<p><code>原型继承存在的问题</code>：<br>1.父类实例私有的属性以及公有的属性都变为子类实例的共有属性<br>2.如果子类B的原型上之前有属性方法，重新执行A的实例后，之前的方法都没用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">this.x=100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype=&#123;</span><br><span class="line">constructor=A;</span><br><span class="line">getX:function()&#123;</span><br><span class="line">console.log(this.x)&#125;&#125;;</span><br><span class="line">function B()&#123;</span><br><span class="line">this.y=200&#125;</span><br><span class="line">B.prototype=new A();</span><br><span class="line">let f=new B();</span><br><span class="line">//原型继承：方式：B.prototype=new A();A的实例本身具备父类A的私有属性和公有方法，子类B的原型指向它，那么子类的B的实例就可以找到这些属性和方法了</span><br><span class="line">//和传统后台语言的继承不一样，子类继承父类并不是把父类的属性方法克隆一份给子类的（这样处理子类和父类就没有直接关系了）js中的原型继承是让子类和父类建立原型链接方式，子类的实例调取父类原型上的方法都是基于原型链的查找机制完成的。存在问题是：子类可以重写父类原型上的方法（重写），子类和父类还有关系的</span><br><span class="line">B.prototype.__proto__.getX=null;//把父类A的原型上的getX重写为null，A的其他实例会受到影响</span><br><span class="line">`原型继承存在的问题`：</span><br><span class="line">1.父类实例私有的属性以及公有的属性都变为子类实例的共有属性</span><br><span class="line">2.如果子类B的原型上之前有属性方法，重新执行A的实例后，之前的方法都没用了。</span><br></pre></td></tr></table></figure></p>
<h5 id="call继承"><a href="#call继承" class="headerlink" title="call继承"></a>call继承</h5><p><code>call继承</code>:把父类A作为普通函数执行，让A中的this变为B的实例，相当于给B的实例增加一些属性和方法<br>new A()把A作为类创建它的实例this:实例。<br>A()把A当做普通函数执行this：window<br><code>弊端</code>：把父类A当做普通函数执行，和父类原型没有关系了，仅仅是把A中的私有属性变为子类B实例的私有属性而已，A原型上的公有属性和B及它的实例没啥关系.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">this.x=100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype=&#123;</span><br><span class="line">constructor=A;</span><br><span class="line">getX:function()&#123;</span><br><span class="line">console.log(this.x)&#125;&#125;;</span><br><span class="line">function B()&#123;</span><br><span class="line">A.call(this);//call继承，把A执行,让A中的this变为f；</span><br><span class="line">this.y=200&#125;</span><br><span class="line"></span><br><span class="line">let f=new B();</span><br><span class="line"></span><br><span class="line">弊端：把父类A当做普通函数执行，和父类原型没有关系了，仅仅是把A中的私有属性变为子类B实例的私有属性而已，A原型上的公有属性和B及它的实例没啥关系</span><br></pre></td></tr></table></figure>
<h5 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h5><p><code>寄生组合继承</code>:A的私有变为B的私有，A的公有变为B的公有<br>和原型继承的唯一区别：B.prototype=new A();创建的A的实例虽然指向了A的原型但是实例中不是空的，存放了A的私有属性，这些属性变为B的公有属性，B.prototype=Object.create(A.prototype)：<code>好处</code>在于我们是创建一个没有任何私有属性的空对象，指向A的原型，这样B的公有属性中就不会存在A的私有属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">this.x=100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype=&#123;</span><br><span class="line">constructor=A;</span><br><span class="line">getX:function()&#123;</span><br><span class="line">console.log(this.x)&#125;&#125;;</span><br><span class="line">function B()&#123;</span><br><span class="line">A.call(this);//call继承，把A执行,让A中的this变为f；</span><br><span class="line">this.y=200&#125;</span><br><span class="line">//B.prototype=A.prototype;//这是组合继承，一般都不这样处理，容易修改父类A原型上的东西，导致A的其他实例也受到影响。</span><br><span class="line">B.prototype=Object.create(A.prototype)</span><br><span class="line">let f=new B();</span><br><span class="line">//Object.create:内置Object类天生自带的方法</span><br><span class="line">1.创建一个空对象</span><br><span class="line">2。让新创建的空对象__proto__指向第一个传递进来的对象（把OBJ作为新创建空对象的原型）</span><br><span class="line">let obj=&#123;name:&apos;haha&apos;&#125;;</span><br><span class="line">Object.create(obj)</span><br></pre></td></tr></table></figure>
<h5 id="ES6class类实现继承"><a href="#ES6class类实现继承" class="headerlink" title="ES6class类实现继承"></a>ES6class类实现继承</h5><p>ES6class类实现继承:创建类是有标准的语法的(这种语法创建出来的类只能new执行，不能当做普通函数执行)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Fn&#123;</span><br><span class="line">constructor(n,m)&#123;</span><br><span class="line">//等价于构造体，代表函数</span><br><span class="line">this.x=n;</span><br><span class="line">this.y=m;&#125;</span><br><span class="line">//直接给Fn的原型上设置方法(只能设置方法不能设置属性)：</span><br><span class="line">getX()&#123;&#125;</span><br><span class="line">//把Fn当做一个普通对象设置的私有方法(和实例没有关系)，同样只能设置方法不能写属性：</span><br><span class="line">static AA()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//属性可以添加在外面</span><br><span class="line">//Fn.prototype.bb=100;</span><br><span class="line">let f=new Fn(10,20)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">construtor()&#123;this.x=100;&#125;</span><br><span class="line">getX()&#123;console.log(this.x)&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;//extends类似于实现了原型继承。</span><br><span class="line">construtor()&#123;super();//类似于call继承，在这里super相当于把A的constructor给执行了并且让方法中的this是B的实例，super当中传递的实参都是在给A的constructor传递</span><br><span class="line">this.y=200;&#125;</span><br><span class="line">getY()&#123;console.log(this.y)&#125;</span><br><span class="line">&#125;</span><br><span class="line">let f= new B();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//public void fn(int n,int m)</span><br><span class="line">//public void fn(string n,string m)&#123;&#125;</span><br><span class="line">//public void fn(int n,int m,int z)&#123;&#125;</span><br><span class="line">根据传递参数的不同执行不同的方法</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn(n,m)&#123;&#125;;</span><br><span class="line">function fn(n,m,x)&#123;</span><br><span class="line">//后面的方法会把前面的方法覆盖掉，不管传递多少实参，执行的都是后面的这个方法（js中的重载值得是：同一个方法根据传参不一样，实现不同的功能）</span><br><span class="line">&#125;;</span><br><span class="line">fn(1,2);</span><br><span class="line">fn(1,2,3)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/DOM精讲/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/DOM精讲/" itemprop="url">DOM精讲</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-04T19:37:34+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="DOM基础精讲"><a href="#DOM基础精讲" class="headerlink" title="DOM基础精讲"></a>DOM基础精讲</h4><blockquote>
<p>DOM：document object model 文档对象模型，提供一些属性和方法可以让我们去操作dom元素</p>
</blockquote>
<h4 id="1-获取DOM元素的方法"><a href="#1-获取DOM元素的方法" class="headerlink" title="1.获取DOM元素的方法"></a>1.获取DOM元素的方法</h4><ul>
<li>document.getElementById 一个元素对象</li>
<li>[context].getElementsByTagName 元素集合</li>
<li>[context].getElementsByClassName 元素集合</li>
<li>document.getElementsByName 节点集合</li>
<li>document.documentElement 获取整个HTML对象</li>
<li>document.body 获取整个body对象</li>
<li>document.head 获取整个head对象</li>
<li>[context].querySelector 一个元素对象</li>
<li>[context].querySelectorAll 获取元素集合</li>
<li>document.docuemnt.clientWidth||docuemnt.body.clientWidth窗口的宽</li>
<li>document.docuemnt.clientHight||docuemnt.body.clientHight窗口的高<h5 id="1-getElementById"><a href="#1-getElementById" class="headerlink" title="1.getElementById"></a>1.getElementById</h5><blockquote>
<p>此方法的上下文只能是document，一个HTML页面中元素的ID理论上是不能重复的</p>
<ul>
<li>如果页面中的ID重复了，我们获取的结果是第一个ID对应的元素对象</li>
<li>在IE7及更低版本浏览器中，会把表单元素的name值当做id来识别使用（项目中尽量不要让表单的name和其它元素的id相同）</li>
<li>如果我们把JS放在结构的下面，我们可以直接使用ID值来获取这个元素（不需要通过getElementById获取），而且这种方式会把页面中所有ID是他的元素都获取到（元素对象/元素集合）  （这种方式不推荐）</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;获取页面中ID值为#box1的所有元素标签</span></span><br><span class="line"><span class="keyword">var</span> allList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>),</span><br><span class="line">    result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; allList.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = allList[i];</span><br><span class="line">    item.id === <span class="string">'box1'</span> ? result.push(item) : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<h5 id="2-getElementsByTagName"><a href="#2-getElementsByTagName" class="headerlink" title="2.getElementsByTagName"></a>2.getElementsByTagName</h5><blockquote>
<ul>
<li>上下文是可以自己来指定</li>
<li>获取到的结果是一个元素集合（类数组集合）<br>获取的结果是集合，哪怕集合中只有一项，我们想要操作这一项（元素对象），需要先从集合中获取出来，然后再操作</li>
<li>在指定的上下文中，获取所有子子孙孙元素中标签名叫做这个的(后代筛选)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var bodyBox=document.getElementsByTagName(&apos;body&apos;);</span><br><span class="line">bodyBox.getElementsByTagName(&apos;div&apos;);//-&gt;Uncaught TypeError: bodyBox.getElementsByTagName is not a function 此时的bodyBox是一个类数组集合，我们需要使用的是其中的第一项，而不是整个集合</span><br><span class="line">bodyBox[0].getElementsByTagName(&apos;div&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h5 id="3-getElementsByClassName"><a href="#3-getElementsByClassName" class="headerlink" title="3.getElementsByClassName"></a>3.getElementsByClassName</h5><blockquote>
<ul>
<li>上下文也可以随意指定，获取的结果也是一个元素集合（类数组集合）</li>
<li>真实项目中我们经常会通过样式类名来获取元素，getElementsByClassName这个方法在IE6~8浏览器中是不兼容的<br>封装dom处理兼容问题</li>
</ul>
</blockquote>
<h5 id="4-getElementsByName"><a href="#4-getElementsByName" class="headerlink" title="4.getElementsByName"></a>4.getElementsByName</h5><blockquote>
<ul>
<li>通过元素的NAME属性值获取一组元素（类数组：节点集合 NodeList）</li>
<li>它的上下文也只能是document</li>
<li>IE浏览器只能识别表单元素的name属性值，所以我们这个方法一般都是用来操作表单元素的</li>
</ul>
</blockquote>
<h5 id="5-document-documentElement-document-body"><a href="#5-document-documentElement-document-body" class="headerlink" title="5.document.documentElement / document.body"></a>5.document.documentElement / document.body</h5><blockquote>
<p>获取html或者body（一个元素对象）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.clientWidth||<span class="built_in">document</span>.body.clientWidth <span class="comment">//=&gt;获取当前浏览器窗口可视区域的宽度（当前页面一屏幕的宽度）</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.clientHeight||<span class="built_in">document</span>.body.clientHeight<span class="comment">//=&gt;获取当前浏览器窗口可视区域的高度（当前页面一屏幕的高度）</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="6-querySelector-querySelectorAll"><a href="#6-querySelector-querySelectorAll" class="headerlink" title="6.querySelector / querySelectorAll"></a>6.querySelector / querySelectorAll</h5><blockquote>
<p>在IE6~8下不兼容，而且也没什么特别好办法处理它的兼容，所以这两个方法一般多用于移动端开发使用<br><code>querySelector</code>：获取一个元素对象<br>console.log(documengt.querySelect(“#list li:nth-child(2)”));获取id是list下面的第二个li。<br><code>querySelectorAll</code>：获取的是一个元素集合<br>只要是CSS支持的选择器，这里大部分都支持</p>
</blockquote>
<h4 id="2-DOM节点的分类"><a href="#2-DOM节点的分类" class="headerlink" title="2.DOM节点的分类"></a>2.DOM节点的分类</h4><blockquote>
<p>node：节点，浏览器认为在一个HTML页面中的所有内容都是节点（包括标签、注释、文字文本等）</p>
<ul>
<li>元素节点：HTML标签</li>
<li>文本节点：文字内容（高版本浏览器会把空格和换行也当做文本节点）</li>
<li>注释节点：注释内容</li>
<li>document文档节点</li>
<li>…</li>
</ul>
</blockquote>
<h5 id="1-元素节点"><a href="#1-元素节点" class="headerlink" title="1.元素节点"></a>1.元素节点</h5><ul>
<li>nodeType：1</li>
<li>nodeName：大写标签名(在部分浏览器的怪异模式下,我们写的标签名是小写,它获取的就是小写…)</li>
<li>nodeValue：null</li>
<li>[curEle].tagName:获取当前元素的标签名（获取的标签名一般都是大写）<h5 id="2-文本节点"><a href="#2-文本节点" class="headerlink" title="2.文本节点"></a>2.文本节点</h5></li>
<li>nodeType：3</li>
<li>nodeName：#text</li>
<li>nodeValue：文本内容<h5 id="3-注释节点"><a href="#3-注释节点" class="headerlink" title="3.注释节点"></a>3.注释节点</h5></li>
<li>nodeType：8</li>
<li>nodeName：#comment</li>
<li>nodeValue：注释内容<h5 id="4-文档节点"><a href="#4-文档节点" class="headerlink" title="4.文档节点"></a>4.文档节点</h5></li>
<li>nodeType：9</li>
<li>nodeName：#document</li>
<li>nodeValue：null</li>
</ul>
<h4 id="3-DOM节点关系属性"><a href="#3-DOM节点关系属性" class="headerlink" title="3.DOM节点关系属性"></a>3.DOM节点关系属性</h4><blockquote>
<p>节点是用来描述页面中每一部分之间关系的，只要我可以获取页面中的一个节点，那么我就可以通过相关的属性和方法获取页面中所有的节点；</p>
</blockquote>
<h5 id="1-childNodes"><a href="#1-childNodes" class="headerlink" title="1.childNodes"></a>1.childNodes</h5><blockquote>
<p>获取当前元素所有的子节点（节点集合：类数组）<br>不仅仅是元素子节点，文本、注释等都会包含在内；子节点说明只是在儿子辈分中查找；</p>
</blockquote>
<h5 id="2-children"><a href="#2-children" class="headerlink" title="2.children"></a>2.children</h5><blockquote>
<p>获取所有的元素子节点（元素集合）<br>在IE6~8下获取的结果和标准浏览器中有区别（IE6~8中会把注释节点当做元素节点获取到）</p>
</blockquote>
<h5 id="3-parentNode"><a href="#3-parentNode" class="headerlink" title="3.parentNode"></a>3.parentNode</h5><blockquote>
<p>获取当前元素的父节点（元素对象）</p>
</blockquote>
<h5 id="4-previousSibling-amp-amp-nextSibling"><a href="#4-previousSibling-amp-amp-nextSibling" class="headerlink" title="4.previousSibling &amp;&amp; nextSibling"></a>4.previousSibling &amp;&amp; nextSibling</h5><blockquote>
<p>previousSibling：获取当前节点的上一个哥哥节点（不一定是元素节点也可能是文本或者注释）<br>nextSibling：获取当前节点的下一个弟弟节点</p>
</blockquote>
<h5 id="5-previousElementSibling-amp-amp-nextElementSibling"><a href="#5-previousElementSibling-amp-amp-nextElementSibling" class="headerlink" title="5.previousElementSibling &amp;&amp;  nextElementSibling"></a>5.previousElementSibling &amp;&amp;  nextElementSibling</h5><blockquote>
<p>previousElementSibling ：获取当前节点的上一个哥哥元素节点<br>nextElementSibling：获取当前节点的下一个弟弟元素节点<br>IE6~8下不兼容</p>
</blockquote>
<h5 id="6-firstChild-amp-amp-lastChild"><a href="#6-firstChild-amp-amp-lastChild" class="headerlink" title="6.firstChild &amp;&amp;  lastChild"></a>6.firstChild &amp;&amp;  lastChild</h5><blockquote>
<p>firstChild：当前元素所有子节点中的第一个（也不一定是元素节点，可能是文本和注释）<br>lastChild：当前元素所有子节点中的最后一个</p>
</blockquote>
<h5 id="7-firstElementChild-amp-amp-lastElementChild"><a href="#7-firstElementChild-amp-amp-lastElementChild" class="headerlink" title="7.firstElementChild   &amp;&amp;  lastElementChild"></a>7.firstElementChild   &amp;&amp;  lastElementChild</h5><blockquote>
<p>获取第一个元素子节点和最后一个元素子节点<br>IE6~8不兼容</p>
</blockquote>
<h4 id="4-创建和增加-以及-修改删除克隆DOM元素"><a href="#4-创建和增加-以及-修改删除克隆DOM元素" class="headerlink" title="4.创建和增加 以及 修改删除克隆DOM元素"></a>4.创建和增加 以及 修改删除克隆DOM元素</h4><blockquote>
<p>真实项目中，我们偶尔会在JS中动态创建一些HTML标签，然后把其增加到页面中</p>
</blockquote>
<h5 id="1-document-createElement"><a href="#1-document-createElement" class="headerlink" title="1.document.createElement"></a>1.document.createElement</h5><blockquote>
<p>在JS中动态创建一个HTML标签</p>
</blockquote>
<h5 id="2-appendChild"><a href="#2-appendChild" class="headerlink" title="2.appendChild"></a>2.appendChild</h5><blockquote>
<p>容器.appendChild(新元素)<br>把当前创建的新元素添加到容器的末尾位置</p>
</blockquote>
<h5 id="3-insertBefore"><a href="#3-insertBefore" class="headerlink" title="3.insertBefore"></a>3.insertBefore</h5><blockquote>
<p>容器.insertBefore(新元素，老元素)<br>在当前容器中，把新创建的元素增加到老元素之前</p>
</blockquote>
<h5 id="4-removeChild"><a href="#4-removeChild" class="headerlink" title="4.removeChild"></a>4.removeChild</h5><blockquote>
<p>容器.removeChild(元素)<br>在当前容器中把某一个元素移除掉</p>
</blockquote>
<h5 id="5-replaceChild"><a href="#5-replaceChild" class="headerlink" title="5.replaceChild"></a>5.replaceChild</h5><blockquote>
<p>容器.replaceChild(新元素,老元素)<br>在当前容器中，拿新元素替换老元素</p>
</blockquote>
<h5 id="6-cloneNode"><a href="#6-cloneNode" class="headerlink" title="6.cloneNode"></a>6.cloneNode</h5><blockquote>
<p>元素.cloneNode(false/true)<br>把原有的元素克隆一份一模一样的，false：只克隆当前元素本身，true：深度克隆，把当前元素本身以及元素的所有后代都进行克隆</p>
</blockquote>
<h5 id="7-set-get-remove-Attribute"><a href="#7-set-get-remove-Attribute" class="headerlink" title="7.set/get/remove]Attribute"></a>7.set/get/remove]Attribute</h5><blockquote>
<p>给当前元素设置/获取/移除 属性的（一般操作的都是它的自定义属性）<br>box.setAttribute(‘myIndex’,0)//(属性名，属性值)<br>box.getAttribute(‘myIndex’)//（属性名）<br>box.removeAttribute(‘myIndex’)</p>
<p>使用xxx.index=0 和 xxx.setAttribute(‘index’,0) 这两种设置自定义属性的区别？</p>
<ul>
<li>xxx.index：是把当前操作的元素当做一个普通对象，为其设置一个属性名（和页面中的HTML标签没关系）；</li>
<li>xxx.setAttribute：把元素当做特殊的元素对象来处理，设置的自定义属性是和页面结构中的DOM元素映射在一起的；</li>
</ul>
</blockquote>
<h5 id="8-document-creatDocumentFragment创建文档碎片"><a href="#8-document-creatDocumentFragment创建文档碎片" class="headerlink" title="8.document.creatDocumentFragment创建文档碎片"></a>8.document.creatDocumentFragment创建文档碎片</h5><p>JS中获取的元素对象，我们可以把它理解为两种角色：</p>
<ul>
<li>与页面HTML结构无关的普通对象</li>
<li>与页面HTML结构存在映射关系的元素对象</li>
</ul>
<blockquote>
<ul>
<li><p>元素对象中的内置属性，大部分都和页面的标签存在映射关系：<br>xxx.style.backgroundColor = ‘xxx’  此时不仅把JS中对象对应的属性值改变了，而且也会映射到页面的HTML标签上（标签中有一个style行内样式、元素的样式改变了）</p>
</li>
<li><p>xxx.className=’xxx’ 此时不仅是把JS对象中的属性值改了，而且页面中的标签增加了class样式类（可以看见的）<br>元素对象中的自定义属性：xxx.index=0 ；仅仅是把JS对象中增加了一个属性名（自定义的），和页面中的HTML没啥关系（在结构上看不见）</p>
</li>
<li>xxx.setAttribute：通过这种方式设置的自定义属性和之前提到的内置属性差不多，都是和HTML结构存在映射关系的（设置的自定义属性可以呈现在结构上）</li>
</ul>
</blockquote>
<h5 id="5-获取当前元素的上一个哥哥元素节点-兼容所有的浏览器"><a href="#5-获取当前元素的上一个哥哥元素节点-兼容所有的浏览器" class="headerlink" title="5. 获取当前元素的上一个哥哥元素节点(兼容所有的浏览器)"></a>5. 获取当前元素的上一个哥哥元素节点(兼容所有的浏览器)</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt; 首先获取当前元素的上一个哥哥节点，判断当前获取的节点是否为元素节点（nodeType===1），如果不是，基于当前获取的节点，找他的上一个哥哥节点...(找几次不知道)一直到找到的节点是元素节点为止</span></span><br><span class="line"><span class="comment">//=&gt; 如果在查找过程中，发现没有上一个哥哥节点了（找到头了），则不在继续查找</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prev</span>(<span class="params">curEle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = curEle.previousSibling;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p.nodeType !== <span class="number">1</span>) &#123;<span class="comment">//-&gt;p:p!==null</span></span><br><span class="line">        p = p.previousSibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;扩展：</span></span><br><span class="line"><span class="comment">//next：获取下一个弟弟元素节点</span></span><br><span class="line"><span class="comment">//prevAll：获取所有的哥哥元素节点</span></span><br><span class="line"><span class="comment">//nextAll：获取所有的弟弟元素节点</span></span><br><span class="line"><span class="comment">//siblings：获取所有的兄弟元素节点</span></span><br><span class="line"><span class="comment">//index：获取当前元素在兄弟中的排名索引</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>获取所有的子节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getChilds(ele)&#123;</span><br><span class="line">var childs=ele.childNodes;</span><br><span class="line">var ary =[];</span><br><span class="line">for(var i= 0;i&lt;childs.length;i++)&#123;</span><br><span class="line">var cur =childs[i];</span><br><span class="line">if(cur.nodetype==1)&#123;</span><br><span class="line">ary.push(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;　return ary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="DOM的重绘和回流"><a href="#DOM的重绘和回流" class="headerlink" title="DOM的重绘和回流"></a>DOM的重绘和回流</h3><blockquote>
<p>我们操作DOM或者修改DOM，基本上就是触发它的重绘和回流机制；</p>
<p>重绘：当一个元素的样式（特点：只有那些不修改元素位置的样式）发生改变的时候，浏览器会把当前元素重新进行渲染（DOM性能消耗低）；</p>
<p>回流：当一个元素的位置发生改变，浏览器会重新把整个页面的DOM结构进行计算，计算出所有元素的最新位置，然后再渲染（DOM性能消耗非常大）：</p>
<ul>
<li>1、新增或者删除一些元素；</li>
<li>2、把现有元素的位置改变；</li>
<li>3、窗口发生改变是可以监听resize事件<br>文档碎片:一个临时存储DOM元素的容器</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var frg=document.createDocumentFragment();</span><br><span class="line">for(var i=0;i&lt;ary.length;i++)&#123;//遍历数组每一项然后追加到文档碎片中</span><br><span class="line">frg.appendChild(ary[i]);</span><br><span class="line">&#125;</span><br><span class="line">listBox.appendChild(frg);//最后把文档碎片追加到容器当中，减少DOM回流，优化提高性能</span><br><span class="line">frg=null;//释放内存</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通俗理解：<br> 浏览器渲染一个页面的时候是按照”先创建一个dom树”-&gt;”加载css”-&gt;”生成渲染树render tree”-&gt;”把渲染树交给浏览器GPU进行绘制”，如果我们后期修改了元素的样式（但是没有改变大小和位置），浏览器会把当前元素重新生成渲染树，然后重新渲染，这个机制是重绘。但是一旦元素的位置或者大小等发生改变，浏览器就要从dom树重新计算渲染，这个机制就是回流（重排），不管是重排还是重绘都非常耗性能，在项目中，要特意重视这个问题，尽量减少操作dom引发的回流问题和重绘问题，基本上常用的解决方案：<br> 1.需要动态向页面追加元素的时候基于文档碎片或者先把需要增加的所有元素拼接成字符串最后统一进行添加。<br> 2.读写分离：把统一修改样式都放到一起执行，新版浏览器都有一个自己检测的机制，如果发现下面紧挨着的操作也是修改元素的样式，会把所有修改的事先存起来，知道遇到非修改样式的操作，会把之前存储的统一执行，引发一次回流和重绘<br>当然还有一些其他的方法，这些是最常注意的，减少dom的回流重绘是非常重要的性能优化手段之一。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/面向对象的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/面向对象的理解/" itemprop="url">面向对象的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-04T17:59:37+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="面向对象（OOP）"><a href="#面向对象（OOP）" class="headerlink" title="面向对象（OOP）"></a>面向对象（OOP）</h3><blockquote>
<p>面试对象是编程思想JAVA、PHP、C#、C++、.net(dot net)、Ruby、Python JS…这些都是面向对象编程的，（面向过程编程思想：C语言是面向过程的）。</p>
</blockquote>
<blockquote>
<p>HTML和CSS是标记语言不是编程语言，没有所谓的面向对象编程<br>LESS/SASS属于CSS预编译语言，旨在把CSS变为编程语言（面向对象）</p>
</blockquote>
<blockquote>
<p>对象、类、实例</p>
</blockquote>
<blockquote>
<p><code>对象</code>：编程语言中的对象是一个泛指，万物接对象（我们所要研究学习以及使用的都是对象）<br><code>类</code>：对象的具体细分（按照属性或者特性细分为一些类别）<br><code>实例</code>：某一类中具体的事物(拿出类别中的具体一个实例进行研究，那么当前类别下的其他实例也具备这些特点和特征。)</p>
</blockquote>
<h3 id="单例模式-singleton-Pattern"><a href="#单例模式-singleton-Pattern" class="headerlink" title="单例模式(singleton Pattern)"></a>单例模式(singleton Pattern)</h3><blockquote>
<p>在真实项目中，为了实现<code>模块化开发</code>或者团队协作开发，我们经常应用单例模式（一般业务逻辑部分的代码都是依托单例模式设计规划的）<br>单例模式命名 的由来：每一个命名空间都是js中Object这个内置类的实例而实例之间是相互独立不干扰的所以我们称之为单例：单独的实例。<br><code>作用</code>：把描述同一件事物的属性和特征进行分组、归类(存储在同一个堆内存空间中)因此避免了全局变量之间的冲突和污染。<br><code>本质</code>：实际上就是一个对象<br>优点：封装性、防止代码冲突和污染<br>模块的调用：<br>不同模块：模块名.属性名来调用<br>同模块：this.属性名，外面用模块名.属性名运行。</p>
</blockquote>
<h3 id="高级单例模式"><a href="#高级单例模式" class="headerlink" title="高级单例模式"></a>高级单例模式</h3><blockquote>
<p>基于JS高阶编程技巧<code>惰性思想</code>来实现的单例模式，并且可以把一些常用的设计模式（例如：命令模式、发布订阅设计模式、promise设计模式等）融合进来，最后清晰的规划我们的业务逻辑代码，方便后期二次开发和维护，这种设计思想综合体就是高级单例模式，也是项目中最常应用的</p>
<ul>
<li>1.在给命名空间赋值的时候不是直接赋值给一个对象，而是先执行匿名函数，形成一个私有作用域(不销毁的栈内存)在AA中创建一个堆内存，把堆内存地址赋值给命名空间.</li>
<li>2.好处是：我们完全可以在AA当中创造很多内容(变量or函数)，哪些需要供外面使用，我们就暴露给返回的对象中(模块化实现的思想)<br>有私有部分，有暴露外面的，功能全，满足需求。<br><code>缺点</code>：只能单个操作效率低，代码冗余。</li>
</ul>
</blockquote>
<h3 id="工厂模式-factory-pattern"><a href="#工厂模式-factory-pattern" class="headerlink" title="工厂模式(factory pattern)"></a>工厂模式(factory pattern)</h3><p>把实现相同功能的代码进行封装，从此来实现批量生产后期想要实现这个功能我们只需要执行函数即可<br>低耦合高内聚，减少代码冗余量。</p>
<blockquote>
<p>1）提供原材料—-新建一个对象<br>2）原材料加工生产—-对对象添加属性和方法<br>3）输出产品—-返回对象<br>缺点：加工出来的全是对象，没法识别，产品的差异化问题没法解决<br>本质：函数</p>
</blockquote>
<h3 id="构造函数-constructor"><a href="#构造函数-constructor" class="headerlink" title="构造函数(constructor)"></a>构造函数(constructor)</h3><blockquote>
<p>在普通函数执行的基础上’new xxx()’这样就不是普通函数执行了而是构造函数执行，当前的函数名称之为“类名”，接收的返回结果是当前类的一个实例</p>
<ul>
<li>这种构造函数设计模式执行，主要用于组件库类插件框架等的封装，平时编写业务逻辑一般不这样处理<br><code>注意事项</code>：<br>1.函数名首字符大写<br>2.this.xxx方式添加属性名，this 指实例<br>3.new 函数名运行，若不需要传参，小括号可不写，需要传参函数名后加括号。<br>4.new运行的函数称为构造函数<br>5.以实例为上下文运行构造函数，运行完成会自动返回这个实例<br>6、this.xxx这个属性是实例的属性，var a=10;只是函数内部的私有属性和实例无关<br>7.若手动增加的返回值return：<br>若返回的是引用类型的数据类型则会覆盖默认返回的实例<br>若返回的是基本类型的数据则不会覆盖。<br>8.this.xxx这些属性都是实例私有的，各个实例之间互不影响。</li>
</ul>
</blockquote>
<p><code>构造函数的创建方式</code></p>
<blockquote>
<p>new  Array(10):创建一个长度为10的数组，数组中的而每一项都是空；<br>new Array(“10”):如果只传递一个实参，并且实参不是数字，相当于把当前数值作为数组的第一项存储进来，如果传递多个实参，不是设置长度，而是把传递的内容当做数组的每一项存储起来。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;name:&apos;dali&apos;&#125;;//</span><br><span class="line">var obj=new Object();//=&gt;一般只用于创建空对象，如果需要增加键值对，创建完成后依次添加即可。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num=12;//字面量创建出来的是一个基本数据类型值（也是Number的一个实例，可以调取Number赋予他的方法</span><br><span class="line">var num=new Number(12);//构造函数方式创建出来的也是Number的一个实例（也是可以使用Number赋予的方法），但是获取的结果是对象数据类型的</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优点：实现产品的差异化，实现分类<br>缺点：所有的属性都是私有的，没法实现公有化<br>例如：有些功能是属于这个类的实例所公有的功能，不需要在每个实例上都实现一遍，只需要每个实例调用下公有的这个功能即可<br>普通函数执行 VS 构造函数执行</p>
</blockquote>
<blockquote>
<p><code>普通函数执行</code><br>1、开辟一个新的私有作用域<br>2、形参赋值<br>3、变量提升<br>4、代码自上而下执行（return后面的值就是当前函数返回的结果）<br>5、栈内存释放或者不释放问题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.function fn(num)&#123;</span><br><span class="line">2.    this.num=num;//=&gt;this:window 给全局对象增加一个num的属性名，属性值是10</span><br><span class="line">3.    var total=null;</span><br><span class="line">4.    total+=num;</span><br><span class="line">5.    return total;</span><br><span class="line">6.&#125;</span><br><span class="line">7.var f=fn(10);//=&gt;f:10</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>构造函数执行</code><br> 1、首先和普通函数执行一样，也需要开辟一个新的私有作用域<br>2、在私有作用域中完成类似于普通函数的操作：形参赋值以及变量提升 –都是<code>私有变量</code>。<br>3、在代码自上而下执行之前，构造函数有属于自己比较特殊的操作：<code>浏览器会在当前的作用域中默认创建一个对象数据类型的值（一个堆内存：暂不存储任何东西），并且会让当前函数中的执行主体this指向创建的这个对象（这个堆内存的地址）</code><br>4、像普通函数一样，代码自上而下执行：<code>this.xxx=xxx这里操作都是在给创建的这个对象（这个堆内存里）增加属性名和属性值</code><br>5、代码执行完成后，即时函数中没有写return，在构造函数模式中：<code>浏览器会默认的把创建的对象返回到函数的外面</code></p>
</blockquote>
<blockquote>
<p>构造函数执行，即具备普通函数执行的一面，也同时具备自己独有的一些操作；<br>在构造函数执行期间，<code>浏览器默认创建的对象（也就是函数体中的this）就是当前这个类的一个实例，代码执行中的this.xxx=xxx都是给实例设置&quot;私有属性&quot;，浏览器会把默认创建的实例返回，供外面接收，再次执行new Fn()，就是把上面的操作克隆一份，会形成新的实例（新的内存空间），所以说实例是相互独立的。返回的结果是Fn这个类的一个实例</code><br><code>深入理解构造函数执行的步骤</code><br>当构造函数或者类，执行的时候不需要传递任何的实参值，此时我们是否加小括号就不重要了（不传递实参的情况下，小括号可以省略）</p>
</blockquote>
<blockquote>
<p>构造函数执行，同时具备了普通函数执行的一面，也有自己特殊的一面，但是和实例相关的，只有自己特殊的一面才相关（也就是 this.xxx=xxx才相当于给当前实例增加的私有属性），函数体中出现的私有变量，和实例都没有直接的关系</p>
</blockquote>
<blockquote>
<p>通过类创建出来的每一个实例都是单独的个体（单独的堆内存空间），实例和实例之间是不相同并且独立互不影响的（市面上部分开发把这种模式叫做单例模式，这种说法是错的，JS中的这种模式叫做构造函数设计模式）</p>
</blockquote>
<blockquote>
<p>在构造函数体中，通过this.xxx=xxx给实例设置的属性都是当前实例的私有属性<br>当构造函数体中我们自己<code>手动的设置了return</code>（<code>默认返回的是实例:对象类型值</code>）, return的是一个<code>基本类型值</code>，对最后返回的实例<code>没有任何的影响</code>，但是如果返回的是<code>引用数据类型</code>的值，<code>会</code>把默认返回的实例<code>替换掉</code>；<br>构造函数执行的时候尽量减少return的使用，防止覆盖实例。<br>如果有return且后面没有返回值，就是结束代码执行的作用并不会覆盖返回的实例。</p>
</blockquote>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><blockquote>
<p>1、所有的函数都天生自带一个属性：prototype（原型）, 它是一个<code>对象</code>数据类型的值，在当前prototype对象中，存储了类需要给其实例使用的<code>公有</code>的属性和方法</p>
</blockquote>
<blockquote>
<p>2、prototype这个对象，浏览器会默认为其开一个<code>堆内存</code>，在这个堆内存中天生自带一个属性：<code>constructor</code>（构造函数），这个属性存储的值就是当前函数本身</p>
</blockquote>
<blockquote>
<p>3、每一个类的实例（每一个对象）都天生自带一个属性：<code>__proto__</code>属性值是当前对象所属类的原型（prototype）<br>原型的基础知识：<br>1.所有的函数（类）（构造函数）里有一个属性叫prototype，protoype是一个对象数据类型会开辟一个堆内存，存储了供其实例使用的公共属性和方法。<br>2.prototype这个对象自带一个属性constructor，他指向与构造函数本身。<br>3.每一个实例（对象）都自带一个属性<code>__proto__</code>这个属性指向所属类的原型</p>
</blockquote>
<blockquote>
<p>prototype里面的属性的都是公有的，所有实例都能访问到<br>构造函数里的this.xxx属性都是实例私有的</p>
</blockquote>
<blockquote>
<p>在实际项目基于面向对象开发的时候（构造原型设计模式）我们根据需要很多时候会定向类的原型（让类的原型指向自己开辟的堆内存）<br>存在的问题<br>1.自己开辟的堆内存中没有constructor属性，导致累的额原型构造函数缺失（解决：自己手动在堆内存中增加constructor属性）<br>2.当原型重定向后浏览器默认开辟的那个原型堆内存会被释放掉，如果之前存储了一些方法或者属性这些东西会丢失(所以内置类的原型不允许重定向到自己开辟的堆内存，因为内置类原型上自带的很多属性方法，重定向之后就都没了，这样是不被允许的)</p>
</blockquote>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><blockquote>
<p>属性查找顺序：<br>1.先在实例上找，若没找到则通过<code>__proto__</code>所属类的原型找，若还没找到，则继续通过<code>__proto__</code>去父类的原型上找…Object.prototype若没找到，则说明不存在。</p>
</blockquote>
<blockquote>
<p><code>isPrototypeOf</code> 判断一个对象是否是在另一个对象的原型链上<br><code>hasOwnproperty</code>判断是否是私有属性<br><code>propertyIsEnumerable</code>是否是可枚举的<br>toSring()转化为字符串，功能是用来检测数据类型，一定要调用的是原型上的toString方法<br>深入学习函数（函数的三种身份：普通函数、类、对象）</p>
<ul>
<li>普通函数<br>作用域，形参赋之，变量提升，代码从上到下<br>函数内变量查找的属性<br>内存释放</li>
<li>构造函数（类）</li>
<li>fn instanceOf Object//-&gt;true<br>Function.__proto__.__proto__==Object.prototype//-&gt;true</li>
</ul>
</blockquote>
<blockquote>
<p>Object.__proto__==Function.prototype//-&gt;true<br>对象</p>
</blockquote>
<blockquote>
<p><code>Object这个</code>类<code>是Function的一个实例
Function的原型是Function.prototype是Object这个类的一个实例
因为Function既是一个函数（类）也是一个对象，自带的\__proto__指向Function.prototype，而Function.prototype的\__proto__又指向Object的原型Object.prototype。因此可以说Function是Object的一个实例</code><br>所有对象都是Object的一实例。就是Object原型上的方法都可以用。<br>所有函数都是Function上的一个实例Function原型上的方法都可以用。call、aplly、bind都可以用<br>面试题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName();<span class="comment">//=&gt;2 把FOO作为对象,找其私有属性</span></span><br><span class="line">getName();<span class="comment">//=&gt;4 执行全局下的GET-NAME</span></span><br><span class="line">Foo().getName();<span class="comment">//=&gt;1 先把FOO作为普通函数执行,把执行的结果window调取GET-NAME在执行</span></span><br><span class="line"><span class="built_in">window</span>.getName();<span class="comment">//=&gt;1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName();<span class="comment">//=&gt;先获取Foo.getName的值(假设B),然后再new B()相当于创建B的实例 =&gt;2  (new Foo.getName;一样的)</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName();<span class="comment">//=&gt;new Foo()当做一个整体获取实例，把得到的实例在调取GET-NAME  =&gt;3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();</span><br><span class="line"><span class="comment">//=&gt;var f=new Foo()//=&gt;实例是this这是空的</span></span><br><span class="line"><span class="comment">//=&gt;new f.getName();  =&gt;new (f.getName)(); =&gt;3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obj.getX();//=&gt;先获取obj的getX的属性值，然后把获取的值执行</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call  apply bind"></a>call  apply bind</h3><blockquote>
<p>都是天生自带的方法(Function.prototype)，所有的函数都可以调取这三个方法<br><code>三个方法都是改变THIS指向的</code><br><code>call</code><br>fn.call(context,para1,…)<br>把fn方法执行，并且让fn方法中的this变为context,而para1…都是给fn传递的实参<br>1.非严格模式下如果参数不传或者第一个传递的是null、undefined，this指向window<br>2.严格模式下第一个参数是谁，this就指向谁（包括null、undefined）不传this是undefined</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;非严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">fn</span>:fn&#125;;</span><br><span class="line">fn();<span class="comment">//=&gt;this:window</span></span><br><span class="line">obj.fn();<span class="comment">//=&gt;this:obj</span></span><br><span class="line"><span class="keyword">var</span> opp=&#123;&#125;;</span><br><span class="line"><span class="comment">//opp.fn();//=&gt;报错:opp中没有fn这个属性</span></span><br><span class="line">fn.call(opp);<span class="comment">//=&gt;this:opp num1&amp;&amp;num2都是undefined</span></span><br><span class="line">fn.call(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//=&gt;this:1 num1=2 num2=undefined</span></span><br><span class="line">fn.call(opp,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//=&gt;this:opp num1=1 num2=2</span></span><br><span class="line"><span class="comment">//-&gt;CALL方法的几个特殊性</span></span><br><span class="line">fn.call();<span class="comment">//=&gt;this:window   num1&amp;&amp;num2都是undefined</span></span><br><span class="line">fn.call(<span class="literal">null</span>);<span class="comment">//=&gt;this:window</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>);<span class="comment">//=&gt;this:window</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;JS严格模式下</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">fn.call();<span class="comment">//=&gt;this:undefined</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>);<span class="comment">//=&gt;this:undefined</span></span><br><span class="line">fn.call(<span class="literal">null</span>);<span class="comment">//=&gt;this:null</span></span><br></pre></td></tr></table></figure>
<p><code>apply</code></p>
<blockquote>
<p>apply的语法和call基本一致，作用原理也基本一致，唯一的区别：apply把传递给函数的实参以数组形式存放（但是也相当于在给函数一个个的传递实参值）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(<span class="literal">null</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">fn.apply(<span class="literal">null</span>,[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]); <span class="comment">//=&gt;传递给fn的时候也是一个个的传递进去的</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><code>bind</code></p>
<blockquote>
<p>也是改变THIS的方法，它在IE6~8下不兼容；它和call(以及apply)改变this的原理不一样，区别于立即执行还是等待执行。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fn.call(opp,<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//=&gt;把fn执行,让fn中的this变为opp,并且把10&amp;&amp;20分别传递给fn</span></span><br><span class="line"></span><br><span class="line">fn.bind(opp,<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//=&gt;预先让fn中的this指向opp,并且把10和20预先传递给fn,此时的fn没有被执行(只有当执行的时候this和实参才会起到应有的作用)</span></span><br><span class="line"><span class="comment">//=&gt;需求：点击box这个盒子的时候，需要执行fn，并且让fn中的this指向opp</span></span><br><span class="line">oBox.onclick=fn; <span class="comment">//=&gt;点击的时候执行了fn,但此时fn中的this是oBox</span></span><br><span class="line"></span><br><span class="line">oBox.onclick=fn.call(opp); <span class="comment">//=&gt;绑定事件的时候就已经把fn立即执行了(call本身就是立即执行函数),然后把fn执行的返回值绑定给事件</span></span><br><span class="line"></span><br><span class="line">oBox.onclick=fn.bind(opp);</span><br><span class="line"><span class="comment">//=&gt;fn.bind(opp)：fn调取Function.prototype上的bind方法，执行这个方法返回了一个匿名函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function()&#123;</span></span><br><span class="line"><span class="comment"> *     fn.call(opp);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">oBox.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//=&gt;this:oBox</span></span><br><span class="line">	fn.call(opp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn1()&#123;console.log(1);&#125;</span><br><span class="line"> function fn2()&#123;console.log(2);&#125;</span><br><span class="line"> fn1.call(fn2);//=&gt;找到CALL-AA把它执行,CALL-AA中的THIS是FN1,第一个参数传递的是FN2  =&gt;在CALL-AA中执行的是FN1 =&gt;1</span><br><span class="line"></span><br><span class="line"> fn1.call.call(fn2);//=&gt;找到CALL-AA让它执行,CALL-AA中的THIS是FN1.CALL,第一个参数是FN2  (把FN1.CALL中的THIS变为FN2，再让FN1.CALL执行  =&gt;先找到CALL-AA，把它执行，只不过此时它中的THIS是FN2 =&gt;让FN2中的THIS变为UNDEFINED，因为执行FN1.CALL的时候没有传递参数值，然后让FN2执行)  =&gt;2</span><br><span class="line"></span><br><span class="line"> Function.prototype.call(fn1);//=&gt;先找到CALL-AA把它执行，它中的THIS是Function.prototype =&gt;让F.P中的THIS变为FN1,然后让F.P执行,F.P是一个匿名函数也是一个空函数，执行没有任何的输出</span><br><span class="line">Function.prototype.call.call(fn1);//=&gt;先找到CALL-AA把它执行，它中的THIS是F.P.CALL =&gt;把F.P.CALL中的THIS修改为FN1,让F.P.CALL执行  =&gt;F.P.CALL(CALL-AA)第二次把它执行(此时它里面的THIS已经是FN1) =&gt;这一次其实在CALL-AA中是让FN1执行 =&gt;1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>查看函数原型上的方法：<br>call/apply/bind-&gt;改变调用主体的this关键字<br>call()第一个参数：用来改变<code>.</code>前面方法的this关键字，从第二个参数开始，以散列式的方式给<code>.</code>前面的方法传参.—散列式.<br>fn.apply()第一个参数：用来改变<code>.</code>前面方法的this关键字，第二个参数是用来给<code>.</code>前面的方法传参（把所有的参数放在数组里传给<code>.</code>前面的方法）—打包式.</p>
</blockquote>
<p>非严格模式下</p>
<blockquote>
<p>call/apply第一个参数不传，传null,传undefined-&gt;<code>.</code>前面方法里的this都是window<br>严格模式下-》规范<br>好处：<br>1.更加安全高效<br>2.提高编译器编译代码的速度<br>3.跟高版本浏览器接轨<br>第一个参数不传是undefined，其他传什么就是什么<br>fn1.call.call.call.call(fn2);<br>最后一个call作用<br>1.让点前面方法里的this关键字改成fn2-&gt;call方法里this-&gt;fn2<br>2.让点前面方法运行-&gt;function.prototype.call()-&gt;this()-&gt;fn2()</p>
</blockquote>
<h3 id="hasOwnProperty-VS-in"><a href="#hasOwnProperty-VS-in" class="headerlink" title="hasOwnProperty VS in"></a>hasOwnProperty VS in</h3><blockquote>
<p>in：用来检测当前这个属性是否隶属于对象（不管是对象私有的还是公有的属性，只要有返回的就是true）</p>
</blockquote>
<blockquote>
<p>hasOwnProperty：用来检测当前这个属性是否是对象的私有属性（不仅要是对象的属性，而且需要是私有的才可以）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;name:&apos;珠峰培训&apos;,age:8&#125;;</span><br><span class="line">&apos;name&apos; in obj  //=&gt;true</span><br><span class="line">&apos;sex&apos; in obj   //=&gt;false</span><br><span class="line">&apos;hasOwnProperty&apos; in obj //=&gt;true  hasOwnProperty是Object这个内置类中提供的属性方法，只要当前对象是Object的一个实例，就可以使用这个方法</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(&apos;name&apos;) //=&gt;true</span><br><span class="line">obj.hasOwnProperty(&apos;hasOwnProperty&apos;) //=&gt;false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>检测一个属性是否是当前对象的公有属性<br>1、是对象的一个属性<br>2、不是对象的私有属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function hasPubProperty(attr,obj)&#123;</span><br><span class="line">    return (attr in obj) &amp;&amp; (obj.hasOwnProperty(attr)===false);</span><br><span class="line">&#125;</span><br><span class="line">hasPubProperty(&apos;hasOwnProperty&apos;,&#123;xxx:&apos;xxx&apos;&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="类的继承：封装和多态"><a href="#类的继承：封装和多态" class="headerlink" title="类的继承：封装和多态"></a>类的继承：封装和多态</h3><p><code>[封装]</code>：把实现一个功能的js代码进行封装主要目的：低耦合高内聚<br><code>[多态]</code>：重载：方法名相同，参数的个数或者类型不同，此时名字相同的方法叫做方法的重载（后台语言的重载），js中不存在重载的<br>重写：子类重写父类的方法<br><code>[继承]</code>：子类继承父类的方法和属性<br><code>原型继承</code>:让子类原型指向父类的一个实例。原型继承方式：B.prototype=new A();A的实例本身具备父类A的私有属性和公有方法，子类B的原型指向它，那么子类的B的实例就可以找到这些属性和方法了.<br>和传统后台语言的继承不一样，子类继承父类并不是把父类的属性方法克隆一份给子类的（这样处理子类和父类就没有直接关系了）js中的原型继承是让子类和父类建立原型链接方式，子类的实例调取父类原型上的方法都是基于原型链的查找机制完成的。存在问题是：子类可以重写父类原型上的方法（重写），子类和父类还有关系的<br>B.prototype.__proto__.getX=null;//把父类A的原型上的getX重写为null，A的其他实例会受到影响<br><code>原型继承存在的问题</code>：<br>1.父类实例私有的属性以及公有的属性都变为子类实例的共有属性<br>2.如果子类B的原型上之前有属性方法，重新执行A的实例后，之前的方法都没用了。</p>
<p><code>call继承</code>:把父类A作为普通函数执行，让A中的this变为B的实例，相当于给B的实例增加一些属性和方法<br>new A()把A作为类创建它的实例this:实例。<br>A()把A当做普通函数执行this：window<br><code>弊端</code>：把父类A当做普通函数执行，和父类原型没有关系了，仅仅是把A中的私有属性变为子类B实例的私有属性而已，A原型上的公有属性和B及它的实例没啥关系.<br><code>寄生组合继承</code>:A的私有变为B的私有，A的公有变为B的公有<br>和原型继承的唯一区别：B.prototype=new A();创建的A的实例虽然指向了A的原型但是实例中不是空的，存放了A的私有属性，这些属性变为B的公有属性，B.prototype=Object.create(A.prototype)：<code>好处</code>在于我们是创建一个没有任何私有属性的空对象，指向A的原型，这样B的公有属性中就不会存在A的私有属性。<br>ES6class类实现继承:创建类是有标准的语法的(这种语法创建出来的类只能new执行，不能当做普通函数执行)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Fn&#123;</span><br><span class="line">constructor(n,m)&#123;</span><br><span class="line">//等价于构造体，代表函数</span><br><span class="line">this.x=n;</span><br><span class="line">this.y=m;&#125;</span><br><span class="line">//直接给Fn的原型上设置方法(只能设置方法不能设置属性)：</span><br><span class="line">getX()&#123;&#125;</span><br><span class="line">//把Fn当做一个普通对象设置的私有方法(和实例没有关系)，同样只能设置方法不能写属性：</span><br><span class="line">static AA()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//属性可以添加在外面</span><br><span class="line">//Fn.prototype.bb=100;</span><br><span class="line">let f=new Fn(10,20)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">construtor()&#123;this.x=100;&#125;</span><br><span class="line">getX()&#123;console.log(this.x)&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;//extends类似于实现了原型继承。</span><br><span class="line">construtor()&#123;super();//类似于call继承，在这里super相当于把A的constructor给执行了并且让方法中的this是B的实例，super当中传递的实参都是在给A的constructor传递</span><br><span class="line">this.y=200;&#125;</span><br><span class="line">getY()&#123;console.log(this.y)&#125;</span><br><span class="line">&#125;</span><br><span class="line">let f= new B();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//public void fn(int n,int m)</span><br><span class="line">//public void fn(string n,string m)&#123;&#125;</span><br><span class="line">//public void fn(int n,int m,int z)&#123;&#125;</span><br><span class="line">根据传递参数的不同执行不同的方法</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn(n,m)&#123;&#125;;</span><br><span class="line">function fn(n,m,x)&#123;</span><br><span class="line">//后面的方法会把前面的方法覆盖掉，不管传递多少实参，执行的都是后面的这个方法（js中的重载值得是：同一个方法根据传参不一样，实现不同的功能）</span><br><span class="line">&#125;;</span><br><span class="line">fn(1,2);</span><br><span class="line">fn(1,2,3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">this.x=100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype=&#123;</span><br><span class="line">constructor=A;</span><br><span class="line">getX:function()&#123;</span><br><span class="line">console.log(this.x)&#125;&#125;;</span><br><span class="line">function B()&#123;</span><br><span class="line">this.y=200&#125;</span><br><span class="line">B.prototype=new A();</span><br><span class="line">let f=new B();</span><br><span class="line">//原型继承：方式：B.prototype=new A();A的实例本身具备父类A的私有属性和公有方法，子类B的原型指向它，那么子类的B的实例就可以找到这些属性和方法了</span><br><span class="line">//和传统后台语言的继承不一样，子类继承父类并不是把父类的属性方法克隆一份给子类的（这样处理子类和父类就没有直接关系了）js中的原型继承是让子类和父类建立原型链接方式，子类的实例调取父类原型上的方法都是基于原型链的查找机制完成的。存在问题是：子类可以重写父类原型上的方法（重写），子类和父类还有关系的</span><br><span class="line">B.prototype.__proto__.getX=null;//把父类A的原型上的getX重写为null，A的其他实例会受到影响</span><br><span class="line">`原型继承存在的问题`：</span><br><span class="line">1.父类实例私有的属性以及公有的属性都变为子类实例的共有属性</span><br><span class="line">2.如果子类B的原型上之前有属性方法，重新执行A的实例后，之前的方法都没用了。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">this.x=100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype=&#123;</span><br><span class="line">constructor=A;</span><br><span class="line">getX:function()&#123;</span><br><span class="line">console.log(this.x)&#125;&#125;;</span><br><span class="line">function B()&#123;</span><br><span class="line">A.call(this);//call继承，把A执行,让A中的this变为f；</span><br><span class="line">this.y=200&#125;</span><br><span class="line"></span><br><span class="line">let f=new B();</span><br><span class="line"></span><br><span class="line">弊端：把父类A当做普通函数执行，和父类原型没有关系了，仅仅是把A中的私有属性变为子类B实例的私有属性而已，A原型上的公有属性和B及它的实例没啥关系</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">this.x=100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype=&#123;</span><br><span class="line">constructor=A;</span><br><span class="line">getX:function()&#123;</span><br><span class="line">console.log(this.x)&#125;&#125;;</span><br><span class="line">function B()&#123;</span><br><span class="line">A.call(this);//call继承，把A执行,让A中的this变为f；</span><br><span class="line">this.y=200&#125;</span><br><span class="line">//B.prototype=A.prototype;//这是组合继承，一般都不这样处理，容易修改父类A原型上的东西，导致A的其他实例也受到影响。</span><br><span class="line">B.prototype=Object.create(A.prototype)</span><br><span class="line">let f=new B();</span><br><span class="line">//Object.create:内置Object类天生自带的方法</span><br><span class="line">1.创建一个空对象</span><br><span class="line">2。让新创建的空对象__proto__指向第一个传递进来的对象（把OBJ作为新创建空对象的原型）</span><br><span class="line">let obj=&#123;name:&apos;haha&apos;&#125;;</span><br><span class="line">Object.create(obj)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/数据类型的检测方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/数据类型的检测方式/" itemprop="url">数据类型的检测方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-04T17:58:32+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="JS中的数据类型检测"><a href="#JS中的数据类型检测" class="headerlink" title="JS中的数据类型检测"></a>JS中的数据类型检测</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><blockquote>
<p>用来检测数据类型的运算符<br>语法：typeof  [value]<br>返回结果：首先是一个字符串，字符串中包含了我们需要检测的数据类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">12</span> =&gt;<span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> =&gt;<span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">''</span> =&gt;<span class="string">'string'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">typeof</span> flag =&gt;<span class="string">'boolean'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> =&gt;<span class="string">'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> =&gt;<span class="string">'object'</span> 虽然是基本类型值，但是它属于空对象指针，检测的结果是对象（局限性）</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; =&gt;<span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  =&gt;<span class="string">'function'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> [] =&gt;<span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> /^$/ =&gt;<span class="string">'object'</span></span><br><span class="line"><span class="comment">//=&gt;使用typeof有自己的局限性：不能具体细分出当前的值是数组还是正则（也就是不能细分对象类型的值）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> (<span class="number">1</span>&gt;<span class="number">1</span>?<span class="number">0</span>:<span class="number">2</span>);  =&gt;<span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>&gt;<span class="number">1</span>?<span class="number">0</span>:<span class="number">2</span>;  =&gt;<span class="number">2</span>  <span class="comment">//=&gt;先计算typeof 1-&gt;'number'  =&gt;'number'&gt;1?0:2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">typeof</span> [] =&gt;<span class="string">'string'</span></span><br><span class="line"><span class="comment">//=&gt;typeof []  =&gt;'object'</span></span><br><span class="line"><span class="comment">//=&gt;typeof 'object'  =&gt;'string'</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="instanceof-amp-constructor"><a href="#instanceof-amp-constructor" class="headerlink" title="instanceof &amp; constructor"></a>instanceof &amp; constructor</h4><blockquote>
<p>instanceof ：检测某一个实例是否隶属于某个类<br>constructor：构造函数</p>
<p>使用instanceof检测某个值是否属于某一个数据类型的内置类，从而检测出它是否是这个类型的值；使用instanceof可以实现typeof实现不了的，对对象类型值详细的区分检测；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>  =&gt;<span class="literal">true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">RegExp</span> =&gt;<span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>使用instanceof检测也有自己的弊端:<br>1、基本类型值无法基于它检测<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">12</span>;</span><br><span class="line">num.toFixed(<span class="number">2</span>)  =&gt;<span class="string">'12.00'</span>  <span class="comment">//=&gt;12是Number类的一个实例，可以调取Number.prototype上的方法，但是它是基本类型值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2=<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">12</span>);</span><br><span class="line">num2.toFixed(<span class="number">2</span>) =&gt;<span class="string">'12.00'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> num =&gt;<span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> num2 =&gt;<span class="string">'object'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;不管是哪一种方式创建基本类型值，都是自己所属类的实例（只不过类型不一样而已）</span></span><br><span class="line">num <span class="keyword">instanceof</span> <span class="built_in">Number</span>  =&gt;<span class="literal">false</span></span><br><span class="line">num2 <span class="keyword">instanceof</span> <span class="built_in">Number</span> =&gt;<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>2、instanceof检测的原理是基于原型链检测的：只要当前类在实例的原型链上，最后返回的结果都是true<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[];</span><br><span class="line">ary <span class="keyword">instanceof</span> <span class="built_in">Array</span>  =&gt;<span class="literal">true</span></span><br><span class="line">ary <span class="keyword">instanceof</span> <span class="built_in">Object</span> =&gt;<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Fn.prototype=<span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//=&gt;原型继承(Fn是Array的子类)</span></span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> Fn();</span><br><span class="line">f <span class="keyword">instanceof</span> <span class="built_in">Array</span> =&gt;<span class="literal">true</span> <span class="comment">//=&gt;但是我们的f其实不应该是数组，虽然在它的原型上可以找到数组，但是它不具备数组的基础结构，这也是instanceof的弊端</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><code>constructor</code></p>
<blockquote>
<p>获取当前要检测数据值的constructor，判断它是否是某一个数据类型内置类来检测<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary=[];</span><br><span class="line">ary.constructor===<span class="function"><span class="params">Array</span> =&gt;</span><span class="literal">true</span></span><br><span class="line">ary.constructor===<span class="function"><span class="params">RegExp</span> =&gt;</span><span class="literal">false</span></span><br><span class="line">ary.constructor===<span class="function"><span class="params">Object</span> =&gt;</span><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">ary.constructor=<span class="string">'AA'</span>;</span><br><span class="line">ary.constructor===<span class="function"><span class="params">Array</span> =&gt;</span><span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;constructor检测数据类型非常不可靠，因为这个属性是经常容易被修改的</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="Object-prototype-toString-call-value"><a href="#Object-prototype-toString-call-value" class="headerlink" title="Object.prototype.toString.call([value])"></a>Object.prototype.toString.call([value])</h4><blockquote>
<p>获取Object.prototype上的toString方法，让方法中的this变为需要检测的数据类型值，并且让方法执行</p>
<p>在Number、String、Boolean、Array、Function、RegExp…这些类的原型上都有一个toString方法：这个方法就是把本身的值转换为字符串的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">12</span>).toString() =&gt;<span class="string">'12'</span></span><br><span class="line">(<span class="literal">true</span>).toString() =&gt;<span class="string">'true'</span></span><br><span class="line">[<span class="number">12</span>,<span class="number">23</span>].toString() =&gt;<span class="string">'12,23'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>在Object这个类的原型上也有一个方法toString，但是这个方法并不是把值转换为字符串，而是<code>返回当前值的所属类详细信息，固定结构：&#39;[object 所属的类]&#39;</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">'珠峰'</span>&#125;;</span><br><span class="line">obj.toString() <span class="comment">//=&gt;"[object Object]" 调取的正是Object.prototype.toString</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * obj.toString()</span></span><br><span class="line"><span class="comment"> *   首先执行Object.prototype.toString方法</span></span><br><span class="line"><span class="comment"> *   这个方法中的this就是我们操作的数据值obj</span></span><br><span class="line"><span class="comment"> *   =&gt;总结：Object.prototype.toString执行的时候会返回当前方法中this的所属类信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   也就是，我想知道谁的所属类信息，我们就把这个toString方法执行，并且让this变为我们检测的这个数据值，那么方法返回的结果就是当前检测这个值的所属类信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Object.prototype.toString.call([value])</span></span><br><span class="line"><span class="comment"> *   (&#123;&#125;).toString.call([value])</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">12</span>) =&gt;<span class="string">"[object Number]"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) =&gt;<span class="string">"[object Boolean]"</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="string">"[object Number]"</span></span><br><span class="line"><span class="string">"[object Boolean]"</span></span><br><span class="line"><span class="string">"[object String]"</span></span><br><span class="line"><span class="string">"[object Null]"</span></span><br><span class="line"><span class="string">"[object Undefined]"</span></span><br><span class="line"><span class="string">"[object Object]"</span></span><br><span class="line"><span class="string">"[object Array]"</span></span><br><span class="line"><span class="string">"[object RegExp]"</span></span><br><span class="line"><span class="string">"[object Function]"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用toString检测数据类型，不管你是啥值，我们都可以正常检测出需要的结果（这个方法检测是万能的）</p>
</blockquote>
<h3 id="检测数据类型方法的封装"><a href="#检测数据类型方法的封装" class="headerlink" title="检测数据类型方法的封装"></a>检测数据类型方法的封装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        isNumber: <span class="string">'Number'</span>,</span><br><span class="line">        isString: <span class="string">'String'</span>,</span><br><span class="line">        isBoolean: <span class="string">'Boolean'</span>,</span><br><span class="line">        isNull: <span class="string">'Null'</span>,</span><br><span class="line">        isUndefined: <span class="string">'Undefined'</span>,</span><br><span class="line">        isPlanObject: <span class="string">'Object'</span>,</span><br><span class="line">        isArray: <span class="string">'Array'</span>,</span><br><span class="line">        isRegExp: <span class="string">'RegExp'</span>,</span><br><span class="line">        isFunction: <span class="string">'Function'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> check = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            check[key] = (<span class="function"><span class="keyword">function</span> (<span class="params">classValue</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\[object '</span> + classValue + <span class="string">'\\]'</span>).test(<span class="built_in">Object</span>.prototype.toString.call(val));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.check = check;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiandali">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tiandali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/数据类型/" itemprop="url">数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-04T17:58:09+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>基本数据类型(值类型)<ul>
<li>Number 数字</li>
<li>String 字符串</li>
<li>Boolean 布尔</li>
<li>null</li>
<li>Undefined</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>object 对象数据类型<ul>
<li>{} 对象object</li>
<li>[] 数组array</li>
<li>/^$/ 正则RegExp</li>
<li>Math数学函数(是window下的一个对象，提供了操作数字的属性和方法。)</li>
<li>Date 的实例（通过new date创造的时间值才是对象）</li>
<li>DOM元素对象</li>
<li>元素或者节点集合</li>
<li>…</li>
</ul>
</li>
<li>function 函数数据类型</li>
</ul>
</li>
</ul>
<h3 id="数据类型的操作原理"><a href="#数据类型的操作原理" class="headerlink" title="数据类型的操作原理"></a>数据类型的操作原理</h3><p><code>基本数据类型</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> b=a;</span><br><span class="line">b=<span class="number">13</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//=&gt;12</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>直接在当前作用域中创建了基本数据类型的值（或者说基本类型值直接存储在当前作用域中），然后把这个值和变量关联起来（一个变量只能关联一个值，关联下一个值后和之前关联的值就没关系了），我们把关联这个操作叫做 <strong>变量赋值</strong>，基本数据类型是直接 <strong>按值操作</strong> 的</p>
</blockquote>
<p><code>引用数据类型</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;<span class="attr">name</span>:<span class="string">'dali'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> p=o;</span><br><span class="line">p.name=<span class="string">'woshidali'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.name);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>引用数据类型不是直接按值操作的（它的结构复杂，要存储很多值，无法直接的创建值），在JS中遇到引用数据类型（对象或者函数），按照如下操作进行：</p>
<p>1、首先开辟一个新的内存空间（浏览器为其分配一个16进制的地址）<br>2、把需要存储的内容存储到内存空间中</p>
<ul>
<li>对象是把键值对依次存储到空间中</li>
<li>函数是把函数体中的代码当做 ‘字符串’ 存储到内存中</li>
</ul>
<p>3、把空间的地址赋值给对应的变量，所以我们也说：引用数据类型是<strong>按照空间的引用地址操作</strong>的</p>
</blockquote>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><blockquote>
<ul>
<li>number有整数 、浮点数值和NaN之分；</li>
<li>NaN：not a number 不是一个数，但是属于number类型的；</li>
<li>isNaN：这个方法是用来检测当前的值是否不是一个有效数字的，如果检测的值不是有效数字返回true，是有效数字返回false；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));<span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">1</span>));<span class="comment">//=&gt;false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'1'</span>));<span class="comment">//=&gt;false 它是有效数字:当浏览器发现我们检测的值不是number类型的时候,首先会默认的把值转换为number类型,然后再验证是否是有效的数字  '1'-&gt;1  isNaN(1)-&gt;false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'12px'</span>));<span class="comment">//=&gt;true  '12px'转换为数字不是有效数字,是NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>));<span class="comment">//=&gt;首先把布尔类型转换为数字 true -&gt;1 false -&gt;0  最后的结果是isNaN(1)-&gt;false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">false</span>));<span class="comment">//=&gt;false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">null</span>));<span class="comment">//=&gt;null转换为数字0 =&gt;false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">undefined</span>));<span class="comment">//=&gt;undefined转换为数字的NaN =&gt;true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="1-Number"><a href="#1-Number" class="headerlink" title="1.Number()"></a>1.Number()</h4><blockquote>
<ul>
<li>把其它数据类型的值转换为number类型；</li>
<li>Number属于强制类型转换，结果要么是纯数字，否则就是NaN<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">//=&gt;1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="comment">//=&gt;0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">//=&gt;0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">//=&gt;NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;使用Number把字符串转换为数字的时候，空字符串是零，其它字符串中如果出现的字符代表纯数字可以转为正常的数字，如果出现了任何一个非有效数字的字符，最后的结果都是NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>) <span class="comment">//=&gt;0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'12'</span>) <span class="comment">//=&gt;12</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'12.5'</span>) <span class="comment">//=&gt;12.5</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'true'</span>) <span class="comment">//=&gt;NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'12px'</span>) <span class="comment">//=&gt;NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;使用Number把引用数据类型转为数字类型的时候，先把引用类型转换为字符串(toString)，然后再把字符串转为数字</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;<span class="attr">name</span>:<span class="string">'zxt'</span>&#125;) <span class="comment">//=&gt; (&#123;name:'zxt'&#125;).toString() =&gt;"[object Object]"</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;&#125;)  <span class="comment">//(&#123;&#125;).toString() =&gt;"[object Object]" =&gt; NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">12</span>,<span class="number">23</span>]) <span class="comment">//[12,23].toString() =&gt; "12,23" =&gt;NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">12</span>]) <span class="comment">//[12].toString() =&gt; "12" =&gt;12</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="string">'aa'</span>]) <span class="comment">// =&gt;NaN</span></span><br><span class="line"><span class="built_in">Number</span>([]) <span class="comment">// =&gt;0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="regexp">/^$/</span>) <span class="comment">//(/^$/).toString() =&gt; "/^$/" =&gt;NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">//=&gt;NaN</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="2-parseInt-转换为整数"><a href="#2-parseInt-转换为整数" class="headerlink" title="2.parseInt() 转换为整数"></a>2.parseInt() 转换为整数</h4><blockquote>
<ul>
<li>也是把其它数据类型转换为数字，整体情况和Number用法一样，</li>
<li>区别在于：在转换字符串的时候，Number是只要出现一个非有效数字字符结果就是NaN；</li>
<li>parseInt没有这么霸道，它能把有效的部分识别出来转为数字，非有效的部分直接忽略掉；</li>
<li>查找机制：在查找转换的时候，按照从左到右的顺序依次查找，一直到遇到一个非有效数字字符结束（不管后面是否还有有效数字字符，都不再继续查找），把找到的转换为数字<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'12px'</span>)  <span class="comment">//=&gt;NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12px'</span>) <span class="comment">//=&gt;12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12px13'</span>) <span class="comment">//=&gt;12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'px13'</span>) <span class="comment">//=&gt;NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>([<span class="number">12</span>,<span class="number">13</span>]) <span class="comment">//=&gt;12</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="3-parseFloat"><a href="#3-parseFloat" class="headerlink" title="3.parseFloat()"></a>3.parseFloat()</h4><blockquote>
<ul>
<li>也是把其它数据类型转换为数字；</li>
<li>用法和parseInt一样，区别在于，parseFloat可以识别小数点；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12.5px'</span>) <span class="comment">//=&gt;12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'12.5px'</span>) <span class="comment">//=&gt;12.5</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'12.5.8px'</span>) <span class="comment">//=&gt;12.5</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'px12.5'</span>) <span class="comment">//=&gt;NaN</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="4-toFixed"><a href="#4-toFixed" class="headerlink" title="4.toFixed()"></a>4.toFixed()</h4><blockquote>
<p>控制数字保留小数点后面几位<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12.5</span>.toFixed() <span class="comment">//=&gt;不写参数,相当于不留小数点，会把数字四舍五入到整数上 =&gt;'13'</span></span><br><span class="line"><span class="number">12.4</span>.toFixed(<span class="number">0</span>) <span class="comment">//=&gt;'12'</span></span><br><span class="line"><span class="number">12.4</span>.toFixed(<span class="number">2</span>) <span class="comment">//=&gt;'12.40'</span></span><br><span class="line"><span class="built_in">Math</span>.PI.toFixed(<span class="number">2</span>) <span class="comment">//=&gt;'3.14'</span></span><br><span class="line"><span class="built_in">Math</span>.PI.toFixed(<span class="number">-2</span>) <span class="comment">//=&gt;Uncaught RangeError: toFixed() digits argument must be between 0 and 20</span></span><br><span class="line">###  String</span><br><span class="line">&gt; &gt; - 在JS中用单(双)引号包裹起来的都是字符串；</span><br><span class="line">&gt; - 字符串就是由零到多个字符组成的,以数字作为索引，从零开始的；</span><br><span class="line">&gt; - 有一个叫做length的属性，存储的是当前字符串中字符的个数（字符串的长度）；</span><br><span class="line">双包单，单包双。</span><br><span class="line">不能单包单，双包双，如果这样必须用转义符\</span><br><span class="line">转义字符：</span><br><span class="line">\\-&gt;\</span><br><span class="line">\<span class="string">'-&gt;'</span></span><br><span class="line">\<span class="string">"-&gt;"</span></span><br><span class="line">\r(回车)\n（换行）</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">12  //-&gt;number</span></span><br><span class="line"><span class="string">'12' //-&gt;string</span></span><br><span class="line"><span class="string">'[12,23]' //-&gt;string</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<ul>
<li>常用方法</li>
<li><p><code>str.charAt(索引)</code>：返回指定索引位置的字符，和str[索引]的区别在于，当指定的索引不存在的时候，中括号的方式获取的是undefined，而charAt获取的是空字符串；</p>
</li>
<li><p><code>str.charCodeAt(索引)</code>：在charAt基础上，把获取的字符变为unicode编码值（对应ASCII码表）；<br>48~57：0-9<br>65~90：A-Z<br>97~122：a-z<br>…</p>
</li>
<li><p><code>String.fromCharCode</code>(十进制的unicode值)：把值按照ASCII码表中的信息，转换为原有的字符，和charCodeAt正好对应；</p>
<ul>
<li>实现字符串截取的三个办法：<br><code>str.substr(n,m)</code>：从索引n开始，截取m个字符；<br><code>str.substring(n,m)</code>：从索引n开始，截取到索引为m处(不包含m)，把找到的部分截取；<br><code>str.slice(n,m)</code>：和substring语法一样，区别在于slice支持以负数做索引；</li>
</ul>
</li>
</ul>
<ul>
<li><p>当<code>索引是负数</code>的时候，浏览器在处理的时候，是用<code>字符串的总长度加上负数索引</code>，然后按照正数处理操作；</p>
</li>
<li><p>如果<code>只传递了n</code>（str.substr(n)/str.substring(n)），相当于从索引n开始一直<code>截取到字符串的末尾</code>；</p>
</li>
<li><p>如果传递的<code>索引超出</code>最大限制，也是把<code>能截取的部分截取掉</code>即可；</p>
</li>
<li><p>如果<code>一个参数都不传递</code>：相当于把整个字符串都截取（字符串的克隆）；<br>str.toUpperCase ：把字母全部大写<br>str.toLowerCase：把字母全局的小写</p>
<ul>
<li>str.indexOf：获取当前字符在字符串中第一次出现位置的索引；</li>
<li>str.lastIndexOf：获取的是最后一次出现位置的索引；</li>
<li>如果当前字符在字符串中没有出现过，结果是-1；我们根据这个规律可以验证一下当前字符串中是否包含某个字符；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str.indexOf(<span class="string">'?'</span>)===<span class="number">-1</span>)&#123;</span><br><span class="line">	<span class="comment">//=&gt;没有出现过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(str.indexOf(<span class="string">'?'</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">//=&gt;出现过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>str.split：按照某一个字符把字符串拆分成数组中的某一项，和数组中的join方法是对应的；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hobbyList = <span class="string">'music|movie|code'</span>;</span><br><span class="line">hobbyList.split(<span class="string">'|'</span>);</span><br><span class="line"><span class="comment">//=&gt; ['music','movie','code']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'name=zhufeng&amp;age=9'</span>;</span><br><span class="line">str.split(<span class="string">'='</span>);</span><br><span class="line"><span class="comment">//=&gt; ["name", "zhufeng&amp;age", "9"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'name=zhufeng&amp;age=9'</span>;</span><br><span class="line">str.split(<span class="regexp">/=|&amp;/g</span>);</span><br><span class="line"><span class="comment">//=&gt; ["name", "zhufeng", "age", "9"]</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<ul>
<li>str.replace：实现字符的替换；</li>
<li>执行一次replace只能替换一次，如果有好几个都需要替换，在不使用正则的情况下我们需要执行很多次replace；</li>
<li>有些需求即使执行很多次replace也实现不了，此时需要使用正则处理，真实项目中replace一般都是和正则搭配使用的<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'dali2017dali2018'</span>;</span><br><span class="line">str = str.replace(<span class="string">'dali'</span>,<span class="string">'tt'</span>)</span><br><span class="line"><span class="comment">//=&gt;'tt2017dali2018';</span></span><br><span class="line">str = str.replace(<span class="string">'dali'</span>,<span class="string">'tt'</span>)</span><br><span class="line"><span class="comment">//=&gt;'tt2017tt2018'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'dali2017tiandali2018'</span>;</span><br><span class="line">str.replace(<span class="regexp">/dali/g</span>,<span class="string">'tian'</span>)</span><br><span class="line"><span class="comment">//=&gt;'tian2017tiantian2018'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>match:一般用于正则捕获</p>
<blockquote>
<p><code>str.trimLeft</code>：去除字符串开始的空格<br><code>str.trimRight</code>：去除字符串结尾的空格<br><code>str.trim</code>：去除字符串首尾的空格<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">'  tian dali  '</span>;</span><br><span class="line">str.trimLeft(); <span class="comment">//=&gt; 'tian dali  '</span></span><br><span class="line">str.trimRight(); <span class="comment">//=&gt; '  tian dali'</span></span><br><span class="line">str.trim(); <span class="comment">//=&gt; 'tian dali'</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>…</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><blockquote>
<ul>
<li>只有两个值：true真/false假</li>
<li><code>Boolean()</code> 把其它数据类型转化为布尔类型，返回的结果为true或者false；</li>
<li>只有<code>0、NaN、空字符串、null、undefined</code>五个会转换为false，其余的都会转换为true<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>) <span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">//=&gt;false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">-1</span>) <span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>) <span class="comment">//=&gt;false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'xxx'</span>) <span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">//=&gt;false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">//=&gt;false</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">//=&gt;true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>取反，把其它数据类型先转换为布尔类型，然后再取反<br><code>!</code>：取一次反<br><code>!!</code>：取两次反(相当于没有取反，只剩把其它类型的值转换为布尔类型，和Boolean是相同的效果)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!<span class="literal">null</span> <span class="comment">//=&gt; true</span></span><br><span class="line">!!<span class="literal">undefined</span> <span class="comment">//=&gt;false</span></span><br><span class="line">![] <span class="comment">//=&gt;false</span></span><br><span class="line">!![] <span class="comment">//=&gt;true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><blockquote>
<ul>
<li>null：空对象指针，但它不是对象类型的，而是基本类型的，表示为空或者没有</li>
<li>undefined：未定义，也代表没有；变量只声明未定义返回的结果为undefined；</li>
</ul>
</blockquote>
<p><code>0或者空字符串</code> 和 <code>null或者undefined</code> 的区别</p>
<blockquote>
<p>0或者空字符串：挖了坑没种树<br>null或者undefined：连坑都没有挖</p>
<p>在JS中null属于没有开辟内存，而空字符串是开辟了内存，里面没有存内容而已，null消耗的性能更低</p>
</blockquote>
<p><code>null</code> 和 <code>undefined</code> 的区别</p>
<blockquote>
<p>null：意料之中的没有，一般都是当前暂时没有，后期基本上会有<br>undefined：意料之外的没有，一般都是当前没有，以后可能有可能没有，但是规划中是不计后面有没有的</p>
<p>dali（男）<br>他的女朋友是null<br>他的男朋友是undefined</p>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>数组也是对象数据类型的 <code>typeof [] -&gt;&#39;object&#39;</code></p>
<p>数组也有属性名，只不过属性名是数字，我们把数字属性名称之为它的索引：数组是以数字作为索引，索引从零开始，有一个length属性代表数组的长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[12,23,34]</span><br><span class="line">0:12</span><br><span class="line">1:23</span><br><span class="line">2:34</span><br><span class="line">length:3</span><br><span class="line">&gt;__proto__:Array(0)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>类数组：类似于数组，但是不是数组<br>1、通过getElementsByTagName获取的元素集合是类数组<br>2、函数中的实参集合arguments也是类数组<br>…</p>
</blockquote>
<h4 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h4><p>conslose.dir(Array.prototype)<br>push()内容添加到末尾<br>unshift()内容添加到开头<br>pop()删除末尾<br>shift()删除开头<br>sort()排序<br>reverse()倒序<br>splice(n,m)从n开始删除m个<br>前七个会改变原数组<br>slice(n,m)截取索引n开始到索引m，但不包括m.<br>concat()拼接<br>toString()转化为字符串<br>join()按照指定分隔符转为字符串<br>indexOf()是否包含某一项返回第一次出现索引<br>last indexOf()是否包含某一项返回最后一次出现索引<br>forEach()遍历每一项<br>map()遍历每一项在forEach基础上可以改值</p>
<p><code>console.dir(Array.prototype)</code></p>
<p>1、方法的意义和作用<br>2、方法的形参<br>3、方法的返回值<br>4、通过此方法，原来的数组是否发生了改变</p>
<h3 id="正则RegExp"><a href="#正则RegExp" class="headerlink" title="正则RegExp"></a>正则RegExp</h3><p>正则：用来处理字符串的一个规则。<br>处理：<br>1）<code>正则的匹配</code>：判断一个字符串是否符合我们制定的规则-&gt;test<br>例如：reg.test(str)<br>/\d/-&gt;包含一个0-9之间的数字<br>var reg=/\d/;<br>console.log(reg.test(“1”))-&gt;true<br>2）<code>正则的捕获</code>：把字符串符合我们正则规则的内容捕获到-&gt;exec<br>例如：reg.exec(str)<br>var reg=/\d/;<br>console.log(reg.exec(“1”))-&gt;[“1”,index:0,input:”1”]</p>
<h4 id="如何创建一个正则："><a href="#如何创建一个正则：" class="headerlink" title="如何创建一个正则："></a>如何创建一个正则：</h4><p>字面量方式：<br><code>var reg =/^\d+$/;</code><br>实例创建方式：<br><code>var reg =new RegExp(&quot;^\\d+$&quot;)</code><br>两种创建方式有区别：<br>1)在字面量方式中，我们//之间包起来的所有内容都是元字符，有的具有特殊的意义，大部分都是代表本身含义的普通的元字符，不能进行变量值的拼接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name =&quot;dali&quot;</span><br><span class="line">var reg =/^\d+&quot;+name+&quot;\d+$/g;</span><br><span class="line">console.log(reg.test(&quot;18dali24&quot;));-&gt;false</span><br><span class="line">console.log(reg.test(&quot;18&quot;&quot;&quot;&quot;&quot;nameeeee&quot;24&quot;));-&gt;true</span><br></pre></td></tr></table></figure></p>
<p>对于字符串拼接这样的需求只能使用实例创建的方式.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reg =new RegExp(&quot;^\\d+&quot;+name+&quot;\\d+$&quot;,&quot;g&quot;)</span><br><span class="line">console.log(reg.test(&quot;18dali24&quot;));-&gt;true</span><br></pre></td></tr></table></figure></p>
<p>2)字面量方式中的\d在实例创建当中要写出\d,前面加一个转义符，因为在字符串当中\d没有被识别成元字符<br>如何学习正则：<br>console.dir(RegExp.prototype)</p>
<h4 id="正则的组成：元字符"><a href="#正则的组成：元字符" class="headerlink" title="正则的组成：元字符"></a>正则的组成：元字符</h4><p>每一个正则表达式都是由元字符和修饰符组成的<br>元字符：在//之间具有意义的一些字符。<br><code>普通元字符</code>：只要在正则出现的元字符（基于字面量方式创建），除了特殊和有量词意义的以外，其余的都是普通元字符<br><code>修饰符</code><br>g(global)：全局匹配<br>i(ignoreCase)：忽略大小写匹配<br>m(multiline)：多行匹配</p>
<h4 id="1-具有特殊意义的元字符"><a href="#1-具有特殊意义的元字符" class="headerlink" title="1.具有特殊意义的元字符"></a>1.具有特殊意义的元字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\：转义字符。转义后面字符所代表的含义</span><br><span class="line">^:以某一个元字符开始</span><br><span class="line">$:以某一个元字符结束</span><br><span class="line">.:除了\n以外的任意字符</span><br><span class="line">():分组，把一个大正则本身划分为几个小正则。`可以改变x|y默认优先级`</span><br><span class="line">(?:):只匹配不捕获</span><br><span class="line">(?=):正向预查</span><br><span class="line">(?!):负向预查</span><br><span class="line">x|y：x或者y中的一个</span><br><span class="line">[xyz]:x或者y或者z中的一个</span><br><span class="line">[^xyz]除了x,y,z的任意一个字符。</span><br><span class="line">[a-z]:a-z之间的任何一个字符</span><br><span class="line">[^a-z]:除了a-z之间的任何一个字符</span><br><span class="line">\d :一个0-9之间的数字</span><br><span class="line">\D：除了0-9之间的数字以外的任何字符</span><br><span class="line">\b:匹配一个边界符</span><br><span class="line">\w:数字、字母、下划线中的任意一个字符[(0-9)(a-z)(A-Z)(_)]</span><br><span class="line">\s：匹配一个空白字符，空格，一个制表符、换页符...</span><br><span class="line">\n匹配一个换行符。</span><br></pre></td></tr></table></figure>
<p>reg=/^\d$/-&gt;<code>只能是`</code>一个<code>0-9之间的数字
console.log(reg.test(&quot;1&quot;))-&gt;true
console.log(reg.test(&quot;012&quot;))-&gt;false
var reg =/^0.2$/;指以0开头，以2结尾，中间可以是除了\n的任意字符。
var reg =/^0\.2$/;指以0开头，以2结尾，中间只能是</code>.`。就是只能是0.2</p>
<h4 id="2-代表出现次数的量词元字符"><a href="#2-代表出现次数的量词元字符" class="headerlink" title="2.代表出现次数的量词元字符"></a>2.代表出现次数的量词元字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*：出现零到多次</span><br><span class="line">+：出现一到多次</span><br><span class="line">?：出现零次或者一次。</span><br><span class="line">&#123;n&#125;：出现n次</span><br><span class="line">&#123;n,&#125;：出现n次到多次</span><br><span class="line">&#123;n,m&#125;：出现n到m次</span><br></pre></td></tr></table></figure>
<p>例如：<br>var reg =/^\d+$/指一到多个数字<br>验证手机号的正则：11位数字，第一位为1:<br>var reg =/^1\d{10}$/;<br><code>[]</code><br>1.中括号中出现的所有字符都是代表本身意思的字符（没有特殊的含义）<br>2.中括号当中不识别两位数<br><code>var reg =/^[12]$/;</code><br>代表的是1或者2中的一个。<br><code>var reg =/^[12-68]$/;</code><br>代表的是1、2-6、8三个当中的一个</p>
<h4 id="元字符详细解读"><a href="#元字符详细解读" class="headerlink" title="元字符详细解读"></a>元字符详细解读</h4><blockquote>
<p><code>()</code>：正则中的分组，也可以理解为一个大正则中的一个正则（包起来的部分是一个整体）；在正则中我们可以使用小括号<code>改变一些默认的优先级</code>；</p>
<p> 小分组还有第二个作用：<code>分组引用</code><br> 小分组的第三个作用：<code>分组捕获</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;分组引用：\1 或者 \2 ...出现和第N个分组一模一样的内容</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^([a-z])([a-z])\2([a-z])$/</span>; <span class="comment">//=&gt; 符合的字符串：foot、book、week、attr、http...</span></span><br></pre></td></tr></table></figure>
<p><code>[]</code></p>
<blockquote>
<p>[xyz] [^xyz] [a-z] [^a-z]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\w：数组字母下划线中的任意一个字符</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[a-zA-Z0-9_]$/</span>; <span class="comment">//=&gt;等价于\w</span></span><br><span class="line"></span><br><span class="line">中括号中出现的元字符，一般都代表本身的含义</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[.?+&amp;]+$/</span>; <span class="comment">//=&gt;里面的四个元字符都是本身含义，例如：点就是小数点了，不是所谓的任意字符...</span></span><br><span class="line"></span><br><span class="line">需求：描述样式类名的规则（数字、字母、下划线、-），并且不能以-开头</span><br><span class="line"><span class="comment">//var reg = /^[\w-]+$/;</span></span><br><span class="line"><span class="comment">//var reg = /^[0-9a-zA-Z_-]+$/; //=&gt;没有处理以-开头的情况</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\w[\w-]*$/</span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><code>|</code>或，操作较混乱<br>例如var reg =/^18|19$/;正常来说是18或者19.<br>但是实际中一下情况都是true<br>1）1开头9结尾<br>2）18或者19<br>3）含有18或者19，例如819也是true<br>可以用（）改变x|y的优先级。</p>
<h4 id="正则的分组"><a href="#正则的分组" class="headerlink" title="正则的分组"></a>正则的分组</h4><p>1.改变优先级<br>2.分组引用<br>3.分组捕获,可以捕获大小正则里的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\2代表和第二个分组出现一模一样的内容；\1代表和一个分组出现一模一样的内容；</span><br><span class="line">var reg =/^(\w)\1(\w)\2$/;</span><br><span class="line">console.log(reg.test(&quot;zzff&quot;));-&gt;true</span><br><span class="line">console.log(reg.test(&quot;z1f_&quot;));-&gt;false</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var reg =/^(\d&#123;2&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(?:\d&#123;2&#125;)(\d)(\d|x)$/;</span><br><span class="line">var str =&quot;654202199404233011&quot;;</span><br><span class="line">console.log(reg.exec(str));</span><br><span class="line">//ary=[&quot;654202199404233011&quot;,&quot;65&quot;,&quot;4202&quot;,&quot;1994&quot;,&quot;04&quot;,&quot;23&quot;,&quot;1&quot;,&quot;1&quot;,index:0,input:&quot;654202199404233011&quot;]</span><br><span class="line">//ary[0]大正则捕获的内容</span><br><span class="line">ary[1]第一个分组捕获的内容</span><br><span class="line">...</span><br><span class="line">（?:）：在分组中只匹配不捕获</span><br></pre></td></tr></table></figure>
<h3 id="正则的匹配"><a href="#正则的匹配" class="headerlink" title="正则的匹配"></a>正则的匹配</h3><p><code>正则的匹配</code>：判断一个字符串是否符合我们制定的规则-&gt;test<br>var reg=/\d/;<br>console.log(reg.test(“1”))-&gt;true</p>
<h3 id="正则的捕获"><a href="#正则的捕获" class="headerlink" title="正则的捕获"></a>正则的捕获</h3><blockquote>
<p>把当前字符串中符合正则的字符捕获到<br>RegExp.prototype：<code>exec</code> 实现正则捕获的方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'珠峰培训2017扬帆起航2018'</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d+/</span>;</span><br><span class="line"></span><br><span class="line">reg.exec(str);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当正则捕获的时候：</span></span><br><span class="line"><span class="comment"> * 1、先去验证当前字符串和正则是否匹配，如果不匹配返回的结果是null（没有捕获到任何的内容）</span></span><br><span class="line"><span class="comment"> * 2、如果匹配，从字符串最左边开始，向右查找到匹配的内容，并且把匹配的内容返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * exec捕获到结果的格式：</span></span><br><span class="line"><span class="comment"> * -&gt; 获取的结果是一个数组</span></span><br><span class="line"><span class="comment"> * -&gt; 数组中的第一项是当前本次大正则在字符串中匹配到的结果</span></span><br><span class="line"><span class="comment"> * -&gt; index：记录了当前本次捕获到结果的起始索引</span></span><br><span class="line"><span class="comment"> * -&gt; input：当前正则操作的原始字符串</span></span><br><span class="line"><span class="comment"> * -&gt; 如果当前正则中有分组，获取的数组中，从第二项开始都是每个小分组，本次匹配到的结果（通过exec可以把分组中的内容捕获到）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 执行一次exec只能把符合正则规则条件中的一个内容捕获都，如果还有其它符合规则的，需要在次执行exec才有可能捕获到</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="懒惰性"><a href="#懒惰性" class="headerlink" title="懒惰性"></a><code>懒惰性</code></h4><p>每一次执行exec只捕获第一个匹配的内容，在不进行任何处理的情况下，在执行多次捕获，捕获的还是第一个匹配的内容。<br>lastindex:是正则每一次捕获在字符串中开始查找的位置，默认的值是0.<br><code>如何解决懒惰性</code>：在正则的末尾加一个修饰符“g”<br><code>原理</code>：加了全局修饰符g，正则每一次捕获结束后，我们的lastindex的值都变为了最新的值，下一次捕获从最新的位置开始查找，这样的就可以把所有需要捕获的内容都捕获到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;a134b&quot;;</span><br><span class="line">var str2=&quot;cc123dd&quot;;</span><br><span class="line">var reg=/\w+/g;</span><br><span class="line">console.log(reg.exec(str));//a134b</span><br><span class="line">conslole.log(reg.lastIndex);//5</span><br><span class="line">console.log(reg.exec(str2));//dd</span><br><span class="line">conslole.log(reg.lastIndex);//7</span><br><span class="line">console.log(reg.exec(str2));//null</span><br><span class="line">conslole.log(reg.lastIndex);//0</span><br><span class="line">console.log(reg.exec(str));//a134b</span><br></pre></td></tr></table></figure>
<p>自己编写程序获取正则捕获的所有内容，一定不能忘记加g<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">没有分组一般就是三个参数：content内容，index索引，input原始字符串</span><br><span class="line">arguments[0]是大正则捕获的内容。</span><br><span class="line">arguments[1]一般就是对应的第1个分组的捕获的内容</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>封装一个方法把匹配的内容一次性捕获到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var reg =/\d+/g;</span><br><span class="line">var str =&quot;d20a21l22i23&quot;;</span><br><span class="line">var ary =[];</span><br><span class="line">var res = reg.exec(str);</span><br><span class="line">while(res)&#123;</span><br><span class="line">ary.push(res[0]);</span><br><span class="line">res = reg.exec(str);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ary)</span><br><span class="line"></span><br><span class="line">----------//或者如下</span><br><span class="line">  RegExp.prototype.allExec=function () &#123;</span><br><span class="line">  if(!this.global)&#123;return this.exec&#125;;</span><br><span class="line">        var ary=[];</span><br><span class="line">        var result;</span><br><span class="line">        while(result==this.exec(str))&#123;</span><br><span class="line">            ary[ary.length]=result[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return ary;</span><br><span class="line">    &#125;;</span><br><span class="line">console.log(reg.allExec(str));</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="正则的贪婪性"><a href="#正则的贪婪性" class="headerlink" title="正则的贪婪性"></a><code>正则的贪婪性</code></h4><p>正则每一次捕获的都是按照匹配的最长的结果捕获的，例如2符合正则，20也符合正则，默认捕获的是20.<br><code>如何解决正则的贪婪性</code>：在量词元字符后面添加一个？即可</p>
<p><code>?</code>:在正则中有很多的作用：<br>1.放在一个普通的元字符后面代表出现0-1次。例如/\d?/数字可能出现也可能不出现。<br>2.放在一个量词的元字符后面是取消捕获时候的贪婪性。<br>3.（?：）在分组中?:的意思是只匹配不捕获。</p>
<h4 id="字符串中的replace方法-捕获匹配正则的字符"><a href="#字符串中的replace方法-捕获匹配正则的字符" class="headerlink" title="字符串中的replace方法 捕获匹配正则的字符"></a>字符串中的replace方法 捕获匹配正则的字符</h4><p> replace原理：</p>
<blockquote>
<p>1、当replace方法执行，第一项传递一个正则<br>正则不加g：把当前字符串中第一个和正则匹配的结果捕获到，替换成新的字符<br>正则加g：把当前字符串中所有和正则匹配的内容都分别的捕获到，而且每一次捕获，都会把当前捕获的内容替换为新字符</p>
<p>2、当replace方法执行，第二个参数传递的是一个函数（回调函数）<br>首先用正则到字符串中进行查找匹配，匹配到一个符合规则的，就把传递的函数执行一次<br>不仅执行这个函数，而且还把正则本次捕获的结果（和执行exec捕获的结果一样：数组、大正则匹配、小分组匹配 都有）当做实参传递给这个函数（这样就可以在函数中获取这些值：而这些值就是正则每一次捕获的结果 ）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'my name is &#123;0&#125;,i am &#123;1&#125; years old,i can &#123;2&#125;!'</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;(\d+)\&#125;/g</span>;</span><br><span class="line">str.replace(reg, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//=&gt;传递的函数一共被执行三次</span></span><br><span class="line">    <span class="comment">//=&gt;console.log(arguments) 每一次匹配捕获到结果,不仅把这个方法执行了,而且还会把当前捕获的结果当做实参传递给这个函数(ARG)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第一次执行函数，获取的是ARG类数组</span></span><br><span class="line"><span class="comment">     *  0:'&#123;0&#125;' 本次大正则匹配的结果</span></span><br><span class="line"><span class="comment">     *  1:'0'   本次第一个小分组匹配的结果</span></span><br><span class="line"><span class="comment">     *  2:11    本次大正则匹配结果在字符串中的索引 index</span></span><br><span class="line"><span class="comment">     *  3:'my nam...' 原始字符串 input</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 和每一次执行exec实现捕获的结果非常类似</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//return xxx;//=&gt;每一次执行函数，函数中RETURN的结果，都相当于把本次大正则匹配的内容替换掉（原始字符串不变）</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="字符串中的match方法-捕获匹配正则的字符"><a href="#字符串中的match方法-捕获匹配正则的字符" class="headerlink" title="字符串中的match方法 捕获匹配正则的字符"></a>字符串中的match方法 捕获匹配正则的字符</h4><p> 使用字符串match捕获：</p>
<blockquote>
<p>1、如果正则加了修饰符g，执行一次match会把所有正则匹配的内容捕获到<br>2、如果没有加修饰符g，执行一次match只能把第一个匹配的结果捕获到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg =/\d+?/g;</span><br><span class="line">var str =&quot;d20a21l22i23&quot;;</span><br><span class="line">var ary =str.match(reg);</span><br><span class="line">console.log(ary);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><code>局限性</code>：在加了修饰符g的情况下，执行match方法只能把大正则匹配的内容捕获到，小正则捕获的内容是无法获取的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.match = function(reg)&#123;</span><br><span class="line">//this--&gt;str我们想操作的那个字符串--&gt;原型上的方法，里面的this都是我们想要操作的当前的实例</span><br><span class="line"></span><br><span class="line">var ary =[];</span><br><span class="line">var res =reg.exec(this);</span><br><span class="line">while(res)&#123;</span><br><span class="line">ary.pus(res[0]);</span><br><span class="line">res =reg.exec(this);</span><br><span class="line">&#125;</span><br><span class="line">return ary;</span><br><span class="line">&#125;;</span><br><span class="line">//str.match(reg);</span><br></pre></td></tr></table></figure>
<h4 id="使用test也可以实现正则的捕获"><a href="#使用test也可以实现正则的捕获" class="headerlink" title="使用test也可以实现正则的捕获"></a>使用test也可以实现正则的捕获</h4><blockquote>
<p>不管是正则的匹配还是正则的捕获，在处理时候的原理是没区别的：<code>从字符串的第一个字符向后查找，找到符合正则规则的字符，如果可以找到，说明正则和字符串匹配（test检测返回true、exec捕获返回捕获的内容），如果找到末尾都没有匹配的，说明正则和字符串不匹配（test检测返回false、exec捕获返回null）</code></p>
<p>如果正则设置了修饰符g，不管使用test还是exec中的任何方法，都会修改lastIndex值（下一次查找是基于上一次匹配结果的末尾开始查找的）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//=&gt;如果当前字符串和正则是匹配的，我们进行捕获</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;(\d+)\&#125;/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'my name is &#123;0&#125;~~'</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">    <span class="comment">//=&gt;reg.test(str) : true</span></span><br><span class="line">    <span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//=&gt;14</span></span><br><span class="line">    <span class="built_in">console</span>.log(reg.exec(str));<span class="comment">//=&gt;null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;(\d+)\&#125;/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'my name is &#123;0&#125;~~'</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">    <span class="comment">//=&gt;reg.test(str) : true</span></span><br><span class="line">    <span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//=&gt;0</span></span><br><span class="line">    <span class="built_in">console</span>.log(reg.exec(str));<span class="comment">//=&gt;['&#123;0&#125;','0'...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>使用test不仅可以找到匹配的内容，也能像exec一样把找到的内容获取到<br>test返回结果是 true/false，所以靠返回结果肯定不行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;(\d+)\&#125;/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'my name is &#123;0&#125;~~,i am &#123;1&#125; years old~~'</span>;</span><br><span class="line">reg.test(str);<span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//=&gt;0 获取到当前本次匹配内容中第一个小分组捕获的内容</span></span><br><span class="line"></span><br><span class="line">reg.test(str);<span class="comment">//=&gt;true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//=&gt;1 TEST可以实现捕获,但是每一次只能获取到当前本次匹配结果中,第N个分组捕获的内容 $1第一个分组 $2第二个分组 ...</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>只匹配不捕获：<br>//在当前一个分组中加了 ?: ，在正则检测匹配的时候，小分组可以起到自己应有的作用（例如：改变优先级…），但是在捕获的时候，遇到带?:的小分组，浏览器不会把当前这个分组中匹配的内容，单独去捕获了</p>
<p>var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(\d{2})(\d)(\d|X)$/;<br>reg.exec(‘130828199012040617’); //=&gt;[“130828199012040617”, “130828”, “1990”, “12”, “04”, “06”, “1”, “7”…]</p>
<p>var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(?:\d{2})(\d)(?:\d|X)$/;<br>reg.exec(‘130828199012040617’);//=&gt; [“130828199012040617”, “130828”, “1990”, “12”, “04”, “1”…]</p>
<p>var reg = /^-?(\d|([1-9]\d+))(.\d+)?$/;//=&gt;计算是第几个分组的时候，我们从左向右找 ( 即可.</p>
<h4 id="重置时间格式"><a href="#重置时间格式" class="headerlink" title="重置时间格式"></a>重置时间格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;2018-3-11 20:41:00&quot;,</span><br><span class="line">//第一步：将指定格式的时间字符中的年月日等信息村入一个数组</span><br><span class="line">reg =/^(\d&#123;4&#125;)[-/](\d&#123;1,2&#125;)[-/](\d&#123;1,2&#125;) +(\d&#123;1,2&#125;):(\d&#123;1,2&#125;):(\d&#123;1,2&#125;)$/g,</span><br><span class="line">ary =&#123;&#125;;</span><br><span class="line">str.replace(reg,function()&#123;</span><br><span class="line">ary = ([].slice.call(arguments)).slice(1,7);</span><br><span class="line">&#125;);</span><br><span class="line">//第二步：设定我们目标时间格式，把数组中对应的项替换成制定的区域内</span><br><span class="line">var resStr =&quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&quot;，</span><br><span class="line">reg =/&#123;(\d+)&#125;/g;</span><br><span class="line">resStr =resStr.replace(reg,function()&#123;</span><br><span class="line">var num = arguments[1],</span><br><span class="line">val = ary[num];</span><br><span class="line">val.length===1?val =&quot;0&quot;+val:void0;</span><br><span class="line">return val;</span><br><span class="line">&#125;);console.log（resStr）</span><br></pre></td></tr></table></figure>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><blockquote>
<p>数学函数：它属于对象数据类型  <code>typeof Math -&gt;&#39;object&#39;</code><br>Math对象中提供了很多操作数字的方法<br><code>console.dir(Math)</code><br>1.Math.abs 取绝对值<br>2.Math.ceil 向上取整</p>
<ol start="3">
<li>Math.floor 向下取整<br>4.Math.round 四舍五入<br>5.Math.random 获取(0,1)之间的随机小数<br>6.Math.max 获取一组值中的最大值<br>7.Math.min 获取一组值中的最小值<br>8.Math.PI 获取圆周率（π）<br>9.Math.pow 获取一个值的多少次幂<br>10.Math.sqrt  开平方</li>
</ol>
</blockquote>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>Date的基础知识</p>
<blockquote>
<p>Date是日期类，通过它可以对时间进行处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">var time = new Date();//=&gt;获取当前客户端本机时间（当前获取的时间不能作为重要的参考依据）</span><br><span class="line">//=&gt;获取的结果是一个日期格式的对象：Sun Oct 22 2017 15:58:40 GMT+0800 (中国标准时间)</span><br><span class="line">typeof new Date() -&gt;&apos;object&apos;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>time.getFullYear() //=&gt;获取四位整数年<br>time.getMonth() //=&gt;获取月（0~11代表1~12月）<br>time.getDate() //=&gt;获取日<br>time.getDay() //=&gt;获取星期（0~6代表周日~周六）<br>time.getHours() //=&gt;获取小时<br>time.getMinutes() //=&gt;获取分钟<br>time.getSeconds() //=&gt;获取秒<br>time.getMilliseconds() //=&gt;获取毫秒<br>time.getTime() //=&gt;获取当前日期距离’1970-01-01 00:00:00’的毫秒差</p>
</blockquote>
<blockquote>
<p>var time = new Date(‘2017-10-22’); //=&gt;当new Date中传递一个时间格式的字符串，相当于把这个字符串转换为标准的时间对象格式（转换完成后，就可以调取上面我们讲的那些方法了）<br>//=&gt;时间格式的字符串<br>‘2017-10-22’  (IE下识别不了)<br>‘2017/10/22’<br>‘2017/10/22 16:15:34’<br>1508659621314 (如果传递的是距离1970年的那个毫秒差，也是可以识别转换的，但是只能是数字，不能是字符串)</p>
</blockquote>
<h4 id="京东倒计时"><a href="#京东倒计时" class="headerlink" title="京东倒计时"></a>京东倒计时</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//=&gt; HTML</span><br><span class="line">&lt;!-- 京东倒计时抢购 --&gt;</span><br><span class="line">&lt;div class=&quot;time&quot;&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;</span><br><span class="line">京东秒杀&lt;br/&gt;距离本场活动结束的时间还有: &lt;span class=&quot;timeBox&quot; id=&quot;timeBox&quot;&gt;00:10:00&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//=&gt; JS</span><br><span class="line">/* 倒计时抢购*/</span><br><span class="line">function computed() &#123;</span><br><span class="line">var timeBox = document.getElementById(&apos;timeBox&apos;);</span><br><span class="line"></span><br><span class="line">var curTime = new Date(); // 电脑当前的时间</span><br><span class="line">var targetTime = new Date(&apos;2018/02/03 16:30&apos;); //我们自己给定的活动结束的时间;</span><br><span class="line">var areaTime = targetTime - curTime;</span><br><span class="line">//console.log(areaTime); //150621 毫秒数</span><br><span class="line"></span><br><span class="line">if (areaTime &lt; 0) &#123;</span><br><span class="line">timeBox.innerHTML = &apos;活动已经结束啦~&apos;;</span><br><span class="line">window.clearInterval(timer);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">/*得到的毫秒数 算出小时*/</span><br><span class="line">var hour = Math.floor(areaTime / (1000 * 60 * 60));</span><br><span class="line"></span><br><span class="line">/*从剩余的毫秒数中 算出分钟*/</span><br><span class="line">areaTime -= hour * 1000 * 60 * 60;</span><br><span class="line">/*减去小时占的毫秒数 剩下再去算分钟占的毫秒数*/</span><br><span class="line">var minutes = Math.floor(areaTime / (1000 * 60));</span><br><span class="line"></span><br><span class="line">/*从剩余的毫秒数中 算出秒*/</span><br><span class="line">areaTime -= minutes * 1000 * 60;</span><br><span class="line">var seconds = Math.floor(areaTime / 1000);</span><br><span class="line"></span><br><span class="line">/*补0的操作 只要小于10 就在前面补一个0*/</span><br><span class="line">hour &lt; 10 ? hour = &apos;0&apos; + hour : hour;</span><br><span class="line">minutes &lt; 10 ? minutes = &apos;0&apos; + minutes : minutes;</span><br><span class="line">seconds &lt; 10 ? seconds = &apos;0&apos; + seconds : seconds;</span><br><span class="line"></span><br><span class="line">timeBox.innerHTML = hour + &apos;:&apos; + minutes + &apos;:&apos; + seconds;</span><br><span class="line">&#125;</span><br><span class="line">computed();</span><br><span class="line">var timer = window.setInterval(computed, 1000); //每隔1s执行一次函数</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tiandali</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tiandali</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
